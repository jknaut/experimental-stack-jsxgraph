<?xml version="1.0" encoding="UTF-8"?>
<quiz>
<!-- question: 356657  -->
  <question type="stack">
    <name>
      <text>[Modular full example] Circle (Synchronous) and Phasor Diagram</text>
    </name>
    <questiontext format="html">
      <text><![CDATA[<p></p>
<p>Von einem zweipoligen Turbogenerator sind folgende Daten bekannt:</p>

<div style="max-width: 40em;">
\[
\begin{align*}
S_{\mathrm{N}} &= {@SN_MVA@} \, \mathrm{MVA} (\mathrm{Y}) \\
U_{\mathrm{N}} &= {@UN_kVY_disp@} \, \mathrm{kV(Y)} \\
\operatorname{cos}(\varphi) &= {@cosphi_disp@} \, \text{(übererregt)} \\
x_{\sigma} &= {@xsigma_disp@} \, \textrm{p.u.} \\
\dfrac{I_{\mathrm{k0}}}{I_{\mathrm{N}}} &= {@INk0_by_IN_disp@} \\
\end{align*}
\]
</div>

<p>Alle Verluste sowie Sättigungserscheinungen dürfen vernachlässigt werden.</p>


<br>
<p>a) Berechnen Sie</p>
<ul>
<li>die Nennleistung \(P_{\mathrm{N}} = \) [[input:ansPN]] [[validation:ansPN]] \(\, \mathrm{MW}\), &nbsp;[[feedback:prtPN]]</li>

<li>den Nennstrom \(I_{\mathrm{N}} = \) [[input:ansIN]] [[validation:ansIN]] \(\, \mathrm{A}\), &nbsp;[[feedback:prtIN]]</li>

<li>die Synchronreaktanz \(X_{\mathrm{d}} = \) [[input:ansXd]] [[validation:ansXd]] \(\, \Omega\), &nbsp;[[feedback:prtXd]]</li>

<li>die Streureaktanz \(X_{\mathrm{\sigma}} = \) [[input:ansXsigma]] [[validation:ansXsigma]] \(\, \Omega\) &nbsp;[[feedback:prtXsigma]] &nbsp;und</li>

<li>die Hauptreaktanz \(X_{\mathrm{h}} = \) [[input:ansXh]] [[validation:ansXh]] \(\, \Omega\). &nbsp;[[feedback:prtXh]]</li></li>

</ul>

<br>
<p>b) Konstruieren Sie die Stromortskurve für Nennerregung (Maßstab \(m_I = {@mI_Abycm@} \, \mathrm{A} / \mathrm{cm}\)) und markieren Sie diese als solche.</p>
<p>Starten Sie mit der Beschriftung der Koordinatenachsen.</p>

[[jsxgraph width="600px" height="600px" input-ref-ansAxisLabels="ansAxisLabelsRef" input-ref-ansSOK="ansSOKRef" input-ref-ansStateStorage="ansStateStorageRef" input-ref-ansBP="ansBPRef"]]

var params = {
  withVectorButton: true,
  checkSOK: true,
  checkBP: true,
};


var createConstructionBoard = (userOptions = {}) => {
    /* Date of last change: 06/04/2025 */
    /* Created by: Johannes Knaut, OTH Amberg-Weiden */

    const defaultOptions = {

        checkSOK: true,
        checkBP: true,
        withVectorButton: true,
        tapePrecision: 1,

        withPhasorDiagram: false,
        vecPositions: [[-9, 11], [-6, 11], [-9, 10], [-6, 10], [-9, 9], [-6, 9], [-9, 8], [-6, 8], [-9, 7], [-6, 7], [-9, 6], [-6, 6], [-9, 5], [-6, 5], [-9, 4], [-6, 4]],
        vecLabels: ["\\(\\underline{U}_1\\)", "\\(\\underline{I}_1\\)", "\\(\\underline{U}_P\\)", "\\(\\underline{I}_{\\mu}\\)", "\\(\\underline{I}'_E\\)", "\\(\\underline{U}_r\\)", "\\(-j X_{1\\sigma} \\cdot \\underline{I}_1\\)", "\\(-j X_h \\cdot \\underline{I}_1\\)"],
        useMathJax: false,

        showStaticAsyncSOK: false,
        xInenncm: 1.67,
        yInenncm: -0.9,
        xIstillcm: 2.78,
        yIstillcm: -11.62,

    };
    const options = { ...defaultOptions, ...userOptions };

    function stringifyMap(map) {
        const mapArray = Array.from(map);
        const jsonStr = JSON.stringify(mapArray);
        return jsonStr;
    }

    function parseMap(jsonString) {
        const mapArray = JSON.parse(jsonString);
        const map = new Map(mapArray);
        return map;
    }

    var changeValue = (ansRef, newValue) => {
        const elem = document.getElementById(ansRef);
        const changeEvent = new Event('change');
        elem.value = newValue;
        elem.dispatchEvent(changeEvent);
    };

    var changeDropdownChoice = (ansRef, newIndex) => {
        const elem = document.getElementById(ansRef);
        const changeEvent = new Event('change');
        elem.selectedIndex = newIndex;
        elem.dispatchEvent(changeEvent);
    };

    function convert2Cart(polarBag) {
        var polarAbs = polarBag.abs;
        var polarAngle = polarBag.angle;
        var real = Math.cos(polarAngle * Math.PI / 180) * polarAbs;
        var imag = Math.sin(polarAngle * Math.PI / 180) * polarAbs;
        var rectNumber = { 'real': real, 'imag': imag };
        return rectNumber;
    }

    function convert2Polar(cartBag) {
        var rectReal = cartBag.real;
        var rectImag = cartBag.imag;
        var abs = Math.sqrt(rectReal * rectReal + rectImag * rectImag);
        var angle = rectReal >= 0 ? JXG.Math.mod(360.0 + Math.atan(rectImag / rectReal) * (180 / Math.PI), 360) : (rectReal < 0 ? 180.0 + Math.atan(rectImag / rectReal) * (180 / Math.PI) : 0.0);
        var polarNumber = { 'abs': abs, 'angle': angle };
        return polarNumber;
    }

    var state = {
        objMap: new Map(), /* maps id to object */
        selectedID: null,
        sokID: "-1",
        bpID: "-1",
    }
    var sokCheckbox = null;
    var bpCheckbox = null;

    const generateId = () => {
        return "id" + Math.random().toString(16).slice(2);
    };

    /* Set global options */
    {
        JXG.Options.axis = JXG.merge(JXG.Options.axis, {
            highlight: false,
            label: { highlight: false },
            ticks: { label: { highlight: false } }
        });
        JXG.Options.line = JXG.merge(JXG.Options.line, {
            highlight: false,
        });
        JXG.Options.curve = JXG.merge(JXG.Options.curve, {
            highlight: false,
        });
        JXG.Options.text = JXG.merge(JXG.Options.text, {
            highlight: false,
            fixed: true,
            useMathJax: options.useMathJax,
        });
        JXG.Options.point = JXG.merge(JXG.Options.point, {
            withLabel: false,
            showInfobox: true,
            infoboxDigits: 2,
        });
        JXG.Options.infobox.anchorY = 'bottom';
        JXG.Options.infobox.anchorX = 'left';
        JXG.Options.infobox.distanceX = -45;
        JXG.Options.infobox.distanceY = 10;
        JXG.Options.infobox.strokeColor = 'black';
    }

    /* Define colors */
    const Colors = {
        isabelline: '#f4f0ec',

        /* colorblind-friendly colors */
        orange: '#E69F00',
        blue: '#0072B2',
        red: '#D55E00',
        green: '#009E73',
        purple: '#CC79A7',
    }

    const selectHandler = (id) => {
        state.selectedID = id;
        if (sokCheckbox) sokCheckbox.rendNodeCheckbox.checked = state.selectedID == state.sokID;
        if (bpCheckbox) bpCheckbox.rendNodeCheckbox.checked = state.selectedID == state.bpID;
    }

    /*board.create('flexvector', [], {});*/
    /* creates a vector from [0,0] to [2, 1] */
    function createFlexVector(board, parents, attributes) {

        var vecState = parents[0];

        const id = vecState.id;
        const is_selected = () => state.selectedID == id;
        const dep_col = () => is_selected() ? Colors.blue : Colors.purple;

        const coordsFirst = vecState.coordsFirst;
        const pFirstStyle = { withLabel: false, color: dep_col, showInfobox: true, infoboxDigits: 2, };
        const pSecondStyle = pFirstStyle;
        const vecStyle = { withLabel: false, strokeColor: dep_col, strokeWidth: 1, opacity: 0.75, lastArrow: { type: 2, size: 14 } };
        var pFirst = board.create('point', coordsFirst, { ...pFirstStyle });
        const coordsSecond = vecState.coordsSecond;
        var pSecond = board.create('point', coordsSecond, { ...pSecondStyle });
        var vec = board.create('segment', [pFirst, pSecond], { ...vecStyle });

        const comp = new JXG.Composition({});

        comp.type = vecState.type;
        comp.id = vecState.id;
        comp.pFirst = pFirst;
        comp.pSecond = pSecond;
        pFirst.on('down', () => selectHandler(id));
        pSecond.on('down', () => selectHandler(id));
        vec.on('down', () => selectHandler(id));

        comp.setAttribute = (attributes) => {
            pFirst.setAttribute(attributes);
            pSecond.setAttribute(attributes);
            vec.setAttribute(attributes);
        }
        comp.removeFromBoard = () => {
            board.removeObject(vec);
            board.removeObject(pFirst);
            board.removeObject(pSecond);
        };

        comp.getState = () => {
            return { type: comp.type, id: comp.id, coordsFirst: [pFirst.X(), pFirst.Y()], coordsSecond: [pSecond.X(), pSecond.Y()] };
        };

        comp.createOriginCopy = (board) => {
            var data = comp.getState();
            data.id = generateId();
            data.coordsFirst = [0, 0];
            data.coordsSecond = [pSecond.X() - pFirst.X(), pSecond.Y() - pFirst.Y()];
            return board.create(data.type, [data], {});
        }

        return comp;
    }

    JXG.createFlexVector = createFlexVector;
    JXG.registerElement('flexvector', JXG.createFlexVector);

    const createOriginVector = (board) => {
        return board.create("flexvector", [{ type: 'flexvector', id: generateId(), coordsFirst: [0, 0], coordsSecond: [2, 1] }], {});
    };

    /*board.create('flexline', [], {});*/
    /* creates a line through origin and [1, 1] */
    function createFlexLine(board, parents, attributes) {

        var lineState = parents[0];

        var id = lineState.id;
        const is_selected = () => state.selectedID == id;
        const dep_col = () => is_selected() ? Colors.blue : Colors.red;

        const coordsFirst = lineState.coordsFirst;
        const pFirstStyle = { withLabel: false, color: dep_col, showInfobox: true, infoboxDigits: 2, };
        const pSecondStyle = pFirstStyle;
        const lineStyle = { withLabel: false, strokeColor: dep_col, strokeWidth: 1, opacity: 0.75 };
        var pFirst = board.create('point', coordsFirst, { ...pFirstStyle });
        const coordsSecond = lineState.coordsSecond;
        var pSecond = board.create('point', coordsSecond, { ...pSecondStyle });
        var line = board.create('line', [pFirst, pSecond], { ...lineStyle });

        const comp = new JXG.Composition({});

        comp.type = lineState.type;
        comp.id = lineState.id;
        pFirst.on('down', () => selectHandler(id));
        pSecond.on('down', () => selectHandler(id));
        line.on('down', () => selectHandler(id));

        comp.setAttribute = (attributes) => {
            pFirst.setAttribute(attributes);
            pSecond.setAttribute(attributes);
            line.setAttribute(attributes);
        }
        comp.removeFromBoard = () => {
            board.removeObject(line);
            board.removeObject(pFirst);
            board.removeObject(pSecond);
        }

        comp.getState = () => {
            return { type: comp.type, id: comp.id, coordsFirst: [pFirst.X(), pFirst.Y()], coordsSecond: [pSecond.X(), pSecond.Y()] };
        };

        /* TODO: Probably always use left lower point of line for new origin... */
        comp.createOriginCopy = (board) => {
            var data = comp.getState();
            data.id = generateId();
            data.coordsFirst = [0, 0];
            data.coordsSecond = [pSecond.X() - pFirst.X(), pSecond.Y() - pFirst.Y()];
            return board.create(data.type, [data], {});
        }

        return comp;
    }

    JXG.createFlexLine = createFlexLine;
    JXG.registerElement('flexline', JXG.createFlexLine);

    const createOriginLine = (board) => {
        return board.create("flexline", [{ type: 'flexline', id: generateId(), coordsFirst: [0, 0], coordsSecond: [1, 1] }], {});
    };

    /*board.create('flexcircle', [radius], {});*/
    /* creates a circle with center in the origin and some radius */
    function createFlexCircle(board, parents, attributes) {

        const cState = parents[0];

        const id = cState.id;
        const radius = cState.radius;
        /*console.log('radius: ' + radius);*/

        const is_selected = () => state.selectedID == id;
        const dep_col = () => is_selected() ? Colors.blue : Colors.orange;
        const coordsOrigin = [0, 0];
        const pCenterStyle = { withLabel: false, fillColor: dep_col, strokeColor: dep_col, showInfobox: true, infoboxDigits: 2, };
        const pRadiusStyle = { withLabel: false, fillColor: dep_col, strokeColor: 'red', strokeWidth: 1, showInfobox: true, infoboxDigits: 2, };
        const circleStyle = { withLabel: false, strokeColor: dep_col, strokeWidth: 1, opacity: 0.75 };
        var pCenter = board.create('point', coordsOrigin, { ...pCenterStyle });
        const coordsRadius = [coordsOrigin[0] + Math.cos(Math.PI / 4) * radius, coordsOrigin[1] + Math.sin(Math.PI / 4) * radius];
        var pRadius = board.create('point', coordsRadius, { ...pRadiusStyle });
        var circle = board.create('circle', [pCenter, pRadius], { ...circleStyle });

        var group = board.create('group', [pCenter, pRadius]);
        group.removeTranslationPoint(pRadius);
        pCenter.moveTo(cState.coordsCenter);
        /*console.log('group id: ' + group.id);*/

        const comp = new JXG.Composition({});

        comp.type = cState.type;
        comp.id = cState.id;
        comp.pCenter = pCenter;
        comp.pRadius = pRadius;
        pCenter.on('down', () => selectHandler(id));
        pRadius.on('down', () => selectHandler(id));
        circle.on('down', () => selectHandler(id));

        pRadius.on('over', () => {
            board.highlightInfobox = function (x, y, el) {
                var nCart = { 'real': x, 'imag': y };
                var nPolar = convert2Polar(nCart);
                /*multiply with i, if y-axis has Re */
                if (pAxisLabelsData && pAxisLabelsData.Y() == 4) {
                    nPolar = { 'abs': nPolar.abs, 'angle': JXG.Math.mod(nPolar.angle - 90.0, 360) };
                }
                var r = nPolar.abs.toFixed(2);
                var phi = nPolar.angle.toFixed(2);
                var radius = JXG.Math.Geometry.distance([pCenter.X(), pCenter.Y()], [x, y], 2).toFixed(2);
                this.infobox.setText('<div style="font-size: 12px; color: grey; background-color: white; border-radius: 4px; border: 1px solid grey; text-align: center;"><span style="color: darkred; padding: 6px; white-space:nowrap;">Radius: ' + radius + '</span></div>');
            };
        });

        pRadius.on('out', () => {
            board.highlightInfobox = function (x, y, el) {
                var nCart = { 'real': x, 'imag': y };
                var nPolar = convert2Polar(nCart);
                /*multiply with i, if y-axis has Re */
                if (pAxisLabelsData && pAxisLabelsData.Y() == 4) {
                    nPolar = { 'abs': nPolar.abs, 'angle': JXG.Math.mod(nPolar.angle - 90.0, 360) };
                }
                var r = nPolar.abs.toFixed(2);
                var phi = nPolar.angle.toFixed(2);
                this.infobox.setText('<div style="font-size: 12px; color: grey; background-color: white; border-radius: 4px; border: 1px solid grey"><span style="color: black; padding: 2px; white-space:nowrap;">(x= ' + x + ', y= ' + y + ')</span><hr style="margin: 2px 0px; border-width: 1px;"><span style="color: blue; padding: 2px; white-space:nowrap;">(r= ' + r + ', &phi;= ' + phi + '&deg;)</span></div>');
            };
        });

        comp.computeRadius = () => {
            return JXG.Math.Geometry.distance([pCenter.X(), pCenter.Y()], [pRadius.X(), pRadius.Y()], 2);
        }
        comp.setAttribute = (attributes) => {
            pCenter.setAttribute(attributes);
            pRadius.setAttribute(attributes);
            circle.setAttribute(attributes);
        }
        comp.removeFromBoard = () => {
            board.removeObject(circle);
            board.removeObject(pCenter);
            board.removeObject(pRadius);

            /* TODO: the next 2 lines have no effect... */
            group.ungroup();
            board.removeObject(group);
        }

        comp.getState = () => {
            const pCenterCoords = [pCenter.X(), pCenter.Y()];
            const pRadiusCoords = [pRadius.X(), pRadius.Y()];
            return { type: comp.type, id: comp.id, coordsCenter: pCenterCoords, radius: JXG.Math.Geometry.distance(pCenterCoords, pRadiusCoords, 2) };
        };

        comp.createOriginCopy = (board) => {
            var data = comp.getState();
            data.id = generateId();
            data.coordsCenter = [0, 0];
            return board.create(data.type, [data], {});
        }

        return comp;
    }

    JXG.createFlexCircle = createFlexCircle;
    JXG.registerElement('flexcircle', JXG.createFlexCircle);

    const createOriginCircle = (board, radius) => {
        return board.create("flexcircle", [{ type: 'flexcircle', id: generateId(), coordsCenter: [0, 0], radius: radius }], {});
    };

    const createGeoObjectFromState = (board, gState) => {
        return board.create(gState.type, [gState], {});
    }

    const optionsText = '<option value="nochoice"></option><option value="-Im">-Im/cm</option><option value="-Re">-Re/cm</option><option value="Im">Im/cm</option><option value="Re">Re/cm</option>';
    const xmin = options.showStaticAsyncSOK ? -5 : -10;
    const xmax = options.showStaticAsyncSOK ? 16 : 11;
    const ymin = -8.5;
    const ymax = 12.5;
    const board = JXG.JSXGraph.initBoard(divid, {
        boundingbox: [xmin, ymax, xmax, ymin],
        axis: true,
        showCopyright: false,
        keepAspectRatio: true,
        defaultAxes: {
            x: {
                name: options.showStaticAsyncSOK ? '-Im/cm' : '<select name="xAxisChoice" id="xAxisChoice">' + optionsText + '</select>',
                withLabel: true,
                label: {
                    position: 'rt',
                    offset: options.showStaticAsyncSOK ? [-40, -30] : [-65, -30],
                    cssStyle: 'font-weight: bold;'
                },
                ticks: {
                    insertTicks: false, // Turn off automatic tick placing
                    minorTicks: 1,      // One minor tick between two major ticks
                    minorHeight: -1,    // Minor ticks are finitely long, too
                    ticksDistance: 1,    // Major ticks are positioned at multiples of one
                    //label: { fontSize: 12, display: 'html', cssClass: 'tickLabels' }
                }
            },
            y: {
                name: options.showStaticAsyncSOK ? 'Re/cm' : '<select name="yAxisChoice" id="yAxisChoice">' + optionsText + '</select>',
                withLabel: true,
                label: {
                    position: 'rt',
                    offset: options.showStaticAsyncSOK ? [-72, -5] : [-92, -5],
                    cssStyle: 'font-weight: bold;'
                },
                ticks: {
                    insertTicks: false, // Turn off automatic tick placing
                    minorTicks: 1,      // No minor ticks between major ticks
                    minorHeight: -1,
                    ticksDistance: 1,    // Major ticks are positioned at multiples of two
                    //label: { fontSize: 12, display: 'html', cssClass: 'tickLabels' }
                }
            }
        },
        zoom: {
            min: 1,
            max: 8
        },
    });


    /* Daten von STACK holen oder verbinden */
    var pAxisLabelsData = null;
    if (!options.showStaticAsyncSOK) {
        var initialChoices = document.getElementById(ansAxisLabelsRef).value;
        pAxisLabelsData = board.create('point', [0, 0], { visible: false, highlight: false, size: 0 });
        stack_jxg.bind_point(ansAxisLabelsRef, pAxisLabelsData);
        changeDropdownChoice('xAxisChoice', Math.round(pAxisLabelsData.X()));
        changeDropdownChoice('yAxisChoice', Math.round(pAxisLabelsData.Y()));

        document.addEventListener('change', (e) => {
            pAxisLabelsData.moveTo([document.getElementById('xAxisChoice').selectedIndex, document.getElementById('yAxisChoice').selectedIndex]);
        });
    }

    var pstyle = { name: '', snapToGrid: false, snapSizeX: 0.1, snapSizeY: 0.1, size: 4, showInfobox: false };

    board.highlightInfobox = function (x, y, el) {
        var nCart = { 'real': x, 'imag': y };
        var nPolar = convert2Polar(nCart);
        /*multiply with i, if y-axis has Re */
        if (pAxisLabelsData && pAxisLabelsData.Y() == 4) {
            nPolar = { 'abs': nPolar.abs, 'angle': JXG.Math.mod(nPolar.angle - 90.0, 360) };
        }
        var r = nPolar.abs.toFixed(2);
        var phi = nPolar.angle.toFixed(2);
        this.infobox.setText('<div style="font-size: 12px; color: grey; background-color: white; border-radius: 4px; border: 1px solid grey"><span style="color: black; padding: 2px; white-space:nowrap;">(x= ' + x + ', y= ' + y + ')</span><hr style="margin: 2px 0px; border-width: 1px;"><span style="color: blue; padding: 2px; white-space:nowrap;">(r= ' + r + ', &phi;= ' + phi + '&deg;)</span></div>');
    };



    const buttonStyle = { frozen: true };

    var addCircleButton = board.create('button', [xmin + 1, ymin + 1, 'Kreis', () => {
        const fCirc1 = createOriginCircle(board, 1);
        state.objMap.set(fCirc1.id, fCirc1);
    }], { ...buttonStyle });
    var addLineButton = board.create('button', [xmin + 3, ymin + 1, 'Gerade', () => {
        const fLine1 = createOriginLine(board);
        state.objMap.set(fLine1.id, fLine1);
    }], { ...buttonStyle });


    var addVectorButton = null;
    if (options.withVectorButton) {
        addVectorButton = board.create('button', [xmin + 5.6, ymin + 1, 'Vektor', () => {
            const fVec1 = createOriginVector(board);
            state.objMap.set(fVec1.id, fVec1);
        }], { ...buttonStyle });
    }




    var yBtnPos = ymax - 1;

    if (options.checkSOK) {
        sokCheckbox = board.create('checkbox', [xmax - 4, yBtnPos, "Stromortskurve"], { fixed: true, frozen: true });
        JXG.addEvent(sokCheckbox.rendNodeCheckbox, 'change', function () {
            if (this.Value()) {
                state.sokID = state.selectedID;
            }
        }, sokCheckbox);
        yBtnPos -= 1;
    }

    if (options.checkBP) {
        bpCheckbox = board.create('checkbox', [xmax - 4, yBtnPos, "Betriebspunkt"], { fixed: true, frozen: true });
        JXG.addEvent(bpCheckbox.rendNodeCheckbox, 'change', function () {
            if (this.Value()) {
                state.bpID = state.selectedID;
            }
        }, bpCheckbox);
        yBtnPos -= 1;
    }


    var copySelectedObjectButton = board.create('button', [xmax - 4, yBtnPos, 'Objekt kopieren', () => {
        if (state.selectedID) {

            const selectedObj = state.objMap.get(state.selectedID);
            const newObj = selectedObj.createOriginCopy(board);
            state.objMap.set(newObj.id, newObj);
        }
    }], { ...buttonStyle });
    yBtnPos -= 1;

    var removeSelectedObjectButton = board.create('button', [xmax - 4, yBtnPos, 'Objekt löschen', () => {
        if (state.selectedID) {
            state.objMap.get(state.selectedID).removeFromBoard();
            state.objMap.delete(state.selectedID);
            state.selectedID = null;
        }
    }], { ...buttonStyle });
    yBtnPos -= 1;



    /***************************************/
    /* Tape measure and angle measure */
    const col5 = 'black';

    var angleStyle = { radius: 0.8, orthoType: 'sector', strokeColor: 'none', withLabel: false };
    var angleLabelStyle = { fontSize: 15, cssStyle: 'font-family: MJXZERO, MJXTEX', fixed: true };

    var myAttractors = [];
    /*
    for(var i = -6; i < 7; i++) {
      if(i==0) continue;
      myAttractors.push(board.create('point', [i, 0], {size: 6, showInfobox: false, color: 'transparent', highlightColor: 'transparent', withLabel: false, fixed: true, highlight: false}));
      myAttractors.push(board.create('point', [0, i], {size: 6, showInfobox: false, color: 'transparent', highlightColor: 'transparent', withLabel: false, fixed: true, highlight: false}));
    }
    */
    var mpls = options.showStaticAsyncSOK ? [[10, -6.5], [15, -6.5], [13, -5], [10, -5], [11.5, -5]] : [[5, -6.5], [10, -6.5], [8, -5], [5, -5], [6.5, -5]];
    var tape = board.create('tapemeasure', [mpls[0], mpls[1]], { name: 'L', precision: options.tapePrecision });
    tape.point1.setAttribute({ ignoredSnapToPoints: [], attractorDistance: 5 });
    tape.point2.setAttribute({ ignoredSnapToPoints: [], attractorDistance: 5 });
    tape.label.setAttribute({ fontWeight: 'bold', strokeColor: 'white', cssStyle: 'backgroundColor: rgba(0, 0, 0, 0.7); padding: 3px' });

    const amPStyle = { showInfobox: false, withLabel: false, size: 6, strokeColor: col5, fillColor: 'transparent', highlightFillColor: 'transparent', attractors: myAttractors, attractorDistance: 0.7, snatchDistance: 0.7 };
    var amStart = board.create('point', mpls[2], { ...amPStyle });
    var amEnd = board.create('point', mpls[3], { ...amPStyle });
    var amCenter = board.create('point', mpls[4], { ...amPStyle });
    var amRightSeg = board.create('segment', [amStart, amCenter], { strokeColor: col5 });
    var amLeftSeg = board.create('segment', [amCenter, amEnd], { strokeColor: col5 });
    var angleMeasure = board.create('angle', [amStart, amCenter, amEnd], { label: { cssStyle: 'backgroundColor: rgba(0, 0, 0, 0.7); padding: 3px', strokeColor: 'white' }, fillColor: col5, strokeColor: col5, name: () => '&phi; = ' + JXG.Math.Geometry.trueAngle(amStart, amCenter, amEnd).toFixed(0) + '°' });
    var amGroup = board.create('group', [amStart, amCenter, amEnd]);
    amGroup.setTranslationPoints([amCenter]);
    /*Zeigerdiagramm*/
    if (options.withPhasorDiagram) {
        var col1 = JXG.paletteWong.blue;
        var col2 = JXG.paletteWong.red;
        var col3 = JXG.paletteWong.green;
        var collight1 = "rgba(0, 72, 178, 0.5)";
        var collight2 = "rgba(213, 94, 0, 0.5)";
        var collight3 = "rgba(0, 158, 115, 0.5)";
        const attDist = 0.3;
        const vecPointStyle = { color: "grey", size: 1, fixed: false, highlight: false, showInfobox: false, snapToGrid: false, snapToPoints: true, attractorDistance: attDist };
        const vecStyle = { withLabel: true, strokeWidth: 1, opacity: 0.75, lastArrow: { type: 2, size: 14 } };
        var pCoords = options.vecPositions;
        var ps = [];
        var vecs = [];
        var vecLabels = options.vecLabels;
        for (let i = 0, j = 0; i < pCoords.length; i++) {
            ps[i] = board.create("point", pCoords[i], { ...vecPointStyle, withLabel: false });
            if (i % 2 == 1) {
                vecs[j] = board.create("arrow", [ps[i - 1], ps[i]], { ...vecStyle, name: vecLabels[j], color: col1, label: { position: () => ps[i].X() <= 0 ? "lft" : "rt", color: "white", cssStyle: `background-color: ${collight1}; padding: 2px 4px; border-radius: 4px;` } });
                j = j + 1;
            }
        }
        var midpoints = [];
        var texts = [];
        for (let j = 0; j < vecs.length; j++) {
            midpoints[j] = board.create("midpoint", [vecs[j]], { size: 0, highlight: false, visible: false, withLabel: false });
            texts[j] = board.create("text", [() => midpoints[j].X(), () => midpoints[j].Y(), () => {
                var nCart = { 'real': vecs[j].point2.X() - vecs[j].point1.X(), 'imag': vecs[j].point2.Y() - vecs[j].point1.Y() };
                var nPolar = convert2Polar(nCart);
                /*multiply with i, if y-axis has Re */
                if (pAxisLabelsData && pAxisLabelsData.Y() == 4) {
                    nPolar = { 'abs': nPolar.abs, 'angle': JXG.Math.mod(nPolar.angle - 90.0, 360) };
                }
                var r = nPolar.abs.toFixed(1);
                var phi = nPolar.angle.toFixed(1);
                return r + " cm, " + phi + "&deg;";
            }], { visible: false, fontSize: 10, anchorX: 'middle', anchorY: 'middle', fontWeight: 'bold', strokeColor: 'white', cssStyle: 'backgroundColor: rgba(0, 0, 0, 0.7); padding: 3px' });
            ps[2 * j + 1].on("mouseover", () => { texts[j].setAttribute({ visible: true }); });
            ps[2 * j + 1].on("mouseout", () => { texts[j].setAttribute({ visible: false }); });
        }
        stack_jxg.bind_list_of(ansZDRef, ps);
    }


    const storedState = JSON.parse(document.getElementById(ansStateStorageRef).value);
    if (storedState != "" || (storedState && storedState.objMap == [])) {
        state.selectedID = storedState.selectedID;
        state.sokID = storedState.sokID;
        state.bpID = storedState.bpID;
        var createObjects = (value, key, map) => {
            map.set(key, createGeoObjectFromState(board, value));
        };
        var preparedState = new Map(storedState.objMap);
        preparedState.forEach(createObjects);
        state.objMap = preparedState;
        if ((state.sokID != "-1" || state.bpID != "-1") && state.selectedID) {
            if (sokCheckbox) sokCheckbox.rendNodeCheckbox.checked = state.selectedID == state.sokID;
            if (bpCheckbox) bpCheckbox.rendNodeCheckbox.checked = state.selectedID == state.bpID;
        }
    } else {
        /* do nothing */
    }


    const interpreteCoords = (coords, csystem) => {
        var m0 = -9999;
        var m1 = -9999;
        var c0 = csystem[0];
        var c1 = csystem[1];
        if (c0 == '-Im') {
            m0 = -coords[1];
        } else if (c0 == 'Im') {
            m0 = coords[1];
        } else if (c0 == '-Re') {
            m0 = -coords[0];
        } else if (c0 == 'Re') {
            m0 = coords[0];
        } else {
            /* do nothing */
        }

        if (c1 == '-Im') {
            m1 = -coords[1];
        } else if (c1 == 'Im') {
            m1 = coords[1];
        } else if (c1 == '-Re') {
            m1 = -coords[0];
        } else if (c1 == 'Re') {
            m1 = coords[0];
        } else {
            /* do nothing */
        }
        var mapped = [m0, m1];
        return mapped;
    };


    /* Muster-SOK anzeigen für x:=(-Im) und y:=Re */

    if (options.showStaticAsyncSOK) {

        const solPStyle = { color: 'darkred' };
        const solVecStyle = { strokeColor: Colors.purple, strokeWidth: 2 };
        const solHelperCircStyle = { visible: false, strokeColor: Colors.orange, strokeWidth: 1 };
        const solSOKStyle = { strokeColor: Colors.blue, strokeWidth: 3 };
        const solLineStyle = { visible: false, strokeColor: 'black', strokeWidth: 2 };
        var p_Inenn_coords = interpreteCoords([options.xInenncm, options.yInenncm], ['-Im', 'Re']);
        var vec_Inenn = board.create("arrow", [[0, 0], p_Inenn_coords], { ...solVecStyle });
        var p_Istill_coords = interpreteCoords([options.xIstillcm, options.yIstillcm], ['-Im', 'Re']);
        var vec_Istill = board.create("arrow", [[0, 0], p_Istill_coords], { ...solVecStyle });
        const helper_circ_radius = Math.max(Math.abs(p_Istill_coords[0]), Math.abs(p_Inenn_coords[0]));
        var helper_circ_Istill = board.create('circle', [p_Istill_coords, helper_circ_radius], { ...solHelperCircStyle });
        var helper_circ_Inenn = board.create('circle', [p_Inenn_coords, helper_circ_radius], { ...solHelperCircStyle });
        var p_Istill = board.create('point', p_Istill_coords, { ...solPStyle, name: 's=1', withLabel: true, showInfobox: false });
        var p_Inenn = board.create('point', p_Inenn_coords, { ...solPStyle, name: 's=s<sub>N</sub>', withLabel: true, showInfobox: false, label: { anchorX: 'right', anchorY: 'bottom' } });
        var line_Inenn_Istill = board.create('line', [p_Istill, p_Inenn], { ...solLineStyle, strokeWidth: 1 });
        var midp_Inenn_Istill = board.create('midpoint', [p_Istill, p_Inenn], { visible: false, ...solPStyle });
        var line_perp = board.create('perpendicular', [line_Inenn_Istill, midp_Inenn_Istill], { ...solLineStyle });
        var center_SOK = board.create('intersection', [board.defaultAxes.x, line_perp], { ...solPStyle, color: Colors.blue });
        var radius_SOK = JXG.Math.Geometry.distance(p_Istill_coords, [center_SOK.X(), center_SOK.Y()], 2);
        var circ_SOK = board.create('circle', [center_SOK, radius_SOK], { ...solSOKStyle });

        var musterElements = [vec_Inenn, vec_Istill, helper_circ_Istill, helper_circ_Inenn, p_Istill, p_Inenn, line_Inenn_Istill, midp_Inenn_Istill, line_perp, center_SOK, circ_SOK];
        for (let i = 0; i < musterElements.length; i++) {
            musterElements[i].setAttribute({ fixed: true, strokeOpacity: 0.7, fillOpacity: 0.7, highlight: false });
        }

    }





    /* TODO: Muster-SOK durch Checkbox anzeigen für x:=(-Im) und y:=Re */
    /*
    const solPStyle = {color: 'darkred'};
    const solVecStyle = {strokeColor: Colors.purple, strokeWidth: 2};
    const solHelperCircStyle = {strokeColor: Colors.orange, strokeWidth: 1};
    const solSOKStyle = {strokeColor: Colors.blue, strokeWidth: 3};
    const solLineStyle = {strokeColor: 'black', strokeWidth: 2};
    var p_Inenn_coords = interpreteCoords([{#xInenncm#}, {#yInenncm#}], ['-Im', 'Re']);
    var vec_Inenn = board.create("arrow", [[0, 0], p_Inenn_coords], {...solVecStyle});
    var p_Istill_coords = interpreteCoords([{#xIstillcm#}, {#yIstillcm#}], ['-Im', 'Re']);
    var vec_Istill = board.create("arrow", [[0, 0], p_Istill_coords], {...solVecStyle});
    const helper_circ_radius = Math.max(Math.abs(p_Istill_coords[0]), Math.abs(p_Inenn_coords[0]));
    var helper_circ_Istill = board.create('circle', [p_Istill_coords, helper_circ_radius], {...solHelperCircStyle});
    var helper_circ_Inenn = board.create('circle', [p_Inenn_coords, helper_circ_radius], {...solHelperCircStyle});
    var p_Istill = board.create('point', p_Istill_coords, {...solPStyle});
    var p_Inenn = board.create('point', p_Inenn_coords, {...solPStyle});
    var line_Inenn_Istill = board.create('line', [p_Istill, p_Inenn], {...solLineStyle, strokeWidth: 1});
    var midp_Inenn_Istill = board.create('midpoint', [p_Istill, p_Inenn], {...solPStyle});
    var line_perp = board.create('perpendicular', [line_Inenn_Istill, midp_Inenn_Istill], {...solLineStyle});
    var center_SOK = board.create('intersection', [board.defaultAxes.x, line_perp], {...solPStyle});
    var radius_SOK = JXG.Math.Geometry.distance(p_Istill_coords, [center_SOK.X(), center_SOK.Y()], 2);
    var circ_SOK = board.create('circle', [center_SOK, radius_SOK], {...solSOKStyle}); 
    
    var musterElements = [vec_Inenn, vec_Istill, helper_circ_Istill, helper_circ_Inenn, p_Istill, p_Inenn, line_Inenn_Istill, midp_Inenn_Istill, line_perp, center_SOK, circ_SOK];
    
    const showSolutionCB = board.create("checkbox", [xmax-8.5, ymin+1.5, "Lösung anzeigen (x= - Im, y= Re)"], {fixed: true, frozen: true});
    showSolutionCB.rendNodeCheckbox.checked = false;
    for(let i = 0; i < musterElements.length; i++) {
      musterElements[i].setAttribute({visible: false, fixed: true, strokeOpacity: 0.7, fillOpacity: 0.7, highlight: false});
    }
    JXG.addEvent(showSolutionCB.rendNodeCheckbox, 'change', function() {
      for(let i = 0; i < musterElements.length; i++) {
        musterElements[i].setAttribute({visible: this.Value()});
      }
    }, showSolutionCB);
    */

    function storeState() {
        /*console.log("storeState");*/
        if (state.sokID !== "-1") {
            /*console.log("sokID is not -1");*/
            var currentSOK = state.objMap.get(state.sokID);
            if (currentSOK) {
                const type = currentSOK.type;
                var coordsCenter = null;
                var radius = -1;
                if (type === "flexcircle") {
                    coordsCenter = [currentSOK.pCenter.X(), currentSOK.pCenter.Y()];
                    radius = currentSOK.computeRadius();
                }
                changeValue(ansSOKRef, JSON.stringify([type, coordsCenter, radius]));
            }
        } else if (options.checkSOK) {
            changeValue(ansSOKRef, JSON.stringify(["-1", [], -1]));
        }

        if (state.bpID !== "-1") {
            /*console.log("bpID is not -1");*/
            var currentBP = state.objMap.get(state.bpID);
            if (currentBP) {
                const type = currentBP.type;
                var coordsStart = null;
                var coordsEnd = null;
                /*console.log("type: " + type);*/
                if (type === "flexvector") {
                    coordsStart = [currentBP.pFirst.X(), currentBP.pFirst.Y()];
                    coordsEnd = [currentBP.pSecond.X(), currentBP.pSecond.Y()];
                    /*console.log(currentBP);*/
                }
                changeValue(ansBPRef, JSON.stringify([type, coordsStart, coordsEnd]));
            }
        } else if (options.checkBP) {
            changeValue(ansBPRef, JSON.stringify(["-1", [], []]));
        }


        var preparedStateMap = new Map(state.objMap);
        var processElements = (value, key, map) => {
            map.set(key, value.getState());
        }
        preparedStateMap.forEach(processElements);
        var preparedStateMapAsArray = Array.from(preparedStateMap);
        var prepState = {
            objMap: preparedStateMapAsArray,
            selectedID: state.selectedID,
            sokID: state.sokID,
            bpID: state.bpID,
        }
        changeValue(ansStateStorageRef, JSON.stringify(prepState));
    }

    board.on('update', storeState);


}; /* end of createConstructionBoard body */
/*********************************************/

createConstructionBoard(params);

[[/jsxgraph]]

<div hidden>
<div>[[input:ansAxisLabels]] [[validation:ansAxisLabels]]</div>
<div>[[input:ansSOK]] [[validation:ansSOK]]</div>
<div>[[input:ansStateStorage]] [[validation:ansStateStorage]]</div>
<div>[[input:ansBP]] [[validation:ansBP]]</div>
</div>

[[feedback:prtSOK]]

<br>
<p>Ermitteln Sie</p>
<ul>
<li>den Lastwinkel \(\vartheta_{\mathrm{LN}} = \) [[input:ansThetaLN]] [[validation:ansThetaLN]] (Grad), &nbsp;[[feedback:prtThetaLN]]</li>

<li>die Polradspannung \(U_{\mathrm{PN}} = \) [[input:ansUPN]] [[validation:ansUPN]] \(\, \mathrm{kV}\) &nbsp;[[feedback:prtUPN]] &nbsp;und</li>

<li>den fiktiven Erregernennstrom \(I'_{\mathrm{EN}} = \) [[input:ansIENFiktiv]] [[validation:ansIENFiktiv]] \(\, \mathrm{kA}\). &nbsp;[[feedback:prtIENFiktiv]]</li>

</ul>

<br>
<p>c) Der Generator wird bei Betrieb am Netz belastet mit \(S = {@S_MVA@} \, \mathrm{MVA}\) bei \(\cos \varphi = {@cosphiS@}\).</p>
<p>Tragen Sie diesen Betriebspunkt <u>oben</u> in die Stromortskurve ein und markieren Sie diesen als solchen.</p>
[[feedback:prtBP]]
<br>
<p>Ist dieser Betrieb dauernd zulässig?</p>
<p>[[input:ansBzYesNo]] [[validation:ansBzYesNo]] &nbsp;<p>[[feedback:prtBzYesNo]]</p></p>
<p>Geben Sie eine Begründung an:</p>
<p>[[input:ansBzReason]] [[validation:ansBzReason]]</p>
<p>[[feedback:prtBzReason]]</p>
<p>Wie groß ist der fiktive Erregerstrom in diesem Betriebspunkt?</p>
<p>\(I'_{\mathrm{E}} = \) [[input:ansIstrichE]] [[validation:ansIstrichE]] \(\, \mathrm{kA}\) &nbsp;[[feedback:prtIstrichE]]</p>

<br>
<p>d) Zeichnen Sie das Zeigerdiagramm für den Betriebspunkt in (c).</p>
[[jsxgraph width="600px" height="600px" input-ref-ansZDAxisLabels="ansAxisLabelsRef" input-ref-ansZD="ansZDRef" input-ref-ansZDStateStorage="ansStateStorageRef"]]

var params = {
  useMathJax: true,
  withPhasorDiagram: true,
  vecLabels: {#vecLabels#},
  tapePrecision: 2,
  withVectorButton: false,
  checkSOK: false,
  checkBP: false,
};


var createConstructionBoard = (userOptions = {}) => {
    /* Date of last change: 06/04/2025 */
    /* Created by: Johannes Knaut, OTH Amberg-Weiden */

    const defaultOptions = {

        checkSOK: true,
        checkBP: true,
        withVectorButton: true,
        tapePrecision: 1,

        withPhasorDiagram: false,
        vecPositions: [[-9, 11], [-6, 11], [-9, 10], [-6, 10], [-9, 9], [-6, 9], [-9, 8], [-6, 8], [-9, 7], [-6, 7], [-9, 6], [-6, 6], [-9, 5], [-6, 5], [-9, 4], [-6, 4]],
        vecLabels: ["\\(\\underline{U}_1\\)", "\\(\\underline{I}_1\\)", "\\(\\underline{U}_P\\)", "\\(\\underline{I}_{\\mu}\\)", "\\(\\underline{I}'_E\\)", "\\(\\underline{U}_r\\)", "\\(-j X_{1\\sigma} \\cdot \\underline{I}_1\\)", "\\(-j X_h \\cdot \\underline{I}_1\\)"],
        useMathJax: false,

        showStaticAsyncSOK: false,
        xInenncm: 1.67,
        yInenncm: -0.9,
        xIstillcm: 2.78,
        yIstillcm: -11.62,

    };
    const options = { ...defaultOptions, ...userOptions };

    function stringifyMap(map) {
        const mapArray = Array.from(map);
        const jsonStr = JSON.stringify(mapArray);
        return jsonStr;
    }

    function parseMap(jsonString) {
        const mapArray = JSON.parse(jsonString);
        const map = new Map(mapArray);
        return map;
    }

    var changeValue = (ansRef, newValue) => {
        const elem = document.getElementById(ansRef);
        const changeEvent = new Event('change');
        elem.value = newValue;
        elem.dispatchEvent(changeEvent);
    };

    var changeDropdownChoice = (ansRef, newIndex) => {
        const elem = document.getElementById(ansRef);
        const changeEvent = new Event('change');
        elem.selectedIndex = newIndex;
        elem.dispatchEvent(changeEvent);
    };

    function convert2Cart(polarBag) {
        var polarAbs = polarBag.abs;
        var polarAngle = polarBag.angle;
        var real = Math.cos(polarAngle * Math.PI / 180) * polarAbs;
        var imag = Math.sin(polarAngle * Math.PI / 180) * polarAbs;
        var rectNumber = { 'real': real, 'imag': imag };
        return rectNumber;
    }

    function convert2Polar(cartBag) {
        var rectReal = cartBag.real;
        var rectImag = cartBag.imag;
        var abs = Math.sqrt(rectReal * rectReal + rectImag * rectImag);
        var angle = rectReal >= 0 ? JXG.Math.mod(360.0 + Math.atan(rectImag / rectReal) * (180 / Math.PI), 360) : (rectReal < 0 ? 180.0 + Math.atan(rectImag / rectReal) * (180 / Math.PI) : 0.0);
        var polarNumber = { 'abs': abs, 'angle': angle };
        return polarNumber;
    }

    var state = {
        objMap: new Map(), /* maps id to object */
        selectedID: null,
        sokID: "-1",
        bpID: "-1",
    }
    var sokCheckbox = null;
    var bpCheckbox = null;

    const generateId = () => {
        return "id" + Math.random().toString(16).slice(2);
    };

    /* Set global options */
    {
        JXG.Options.axis = JXG.merge(JXG.Options.axis, {
            highlight: false,
            label: { highlight: false },
            ticks: { label: { highlight: false } }
        });
        JXG.Options.line = JXG.merge(JXG.Options.line, {
            highlight: false,
        });
        JXG.Options.curve = JXG.merge(JXG.Options.curve, {
            highlight: false,
        });
        JXG.Options.text = JXG.merge(JXG.Options.text, {
            highlight: false,
            fixed: true,
            useMathJax: options.useMathJax,
        });
        JXG.Options.point = JXG.merge(JXG.Options.point, {
            withLabel: false,
            showInfobox: true,
            infoboxDigits: 2,
        });
        JXG.Options.infobox.anchorY = 'bottom';
        JXG.Options.infobox.anchorX = 'left';
        JXG.Options.infobox.distanceX = -45;
        JXG.Options.infobox.distanceY = 10;
        JXG.Options.infobox.strokeColor = 'black';
    }

    /* Define colors */
    const Colors = {
        isabelline: '#f4f0ec',

        /* colorblind-friendly colors */
        orange: '#E69F00',
        blue: '#0072B2',
        red: '#D55E00',
        green: '#009E73',
        purple: '#CC79A7',
    }

    const selectHandler = (id) => {
        state.selectedID = id;
        if (sokCheckbox) sokCheckbox.rendNodeCheckbox.checked = state.selectedID == state.sokID;
        if (bpCheckbox) bpCheckbox.rendNodeCheckbox.checked = state.selectedID == state.bpID;
    }

    /*board.create('flexvector', [], {});*/
    /* creates a vector from [0,0] to [2, 1] */
    function createFlexVector(board, parents, attributes) {

        var vecState = parents[0];

        const id = vecState.id;
        const is_selected = () => state.selectedID == id;
        const dep_col = () => is_selected() ? Colors.blue : Colors.purple;

        const coordsFirst = vecState.coordsFirst;
        const pFirstStyle = { withLabel: false, color: dep_col, showInfobox: true, infoboxDigits: 2, };
        const pSecondStyle = pFirstStyle;
        const vecStyle = { withLabel: false, strokeColor: dep_col, strokeWidth: 1, opacity: 0.75, lastArrow: { type: 2, size: 14 } };
        var pFirst = board.create('point', coordsFirst, { ...pFirstStyle });
        const coordsSecond = vecState.coordsSecond;
        var pSecond = board.create('point', coordsSecond, { ...pSecondStyle });
        var vec = board.create('segment', [pFirst, pSecond], { ...vecStyle });

        const comp = new JXG.Composition({});

        comp.type = vecState.type;
        comp.id = vecState.id;
        comp.pFirst = pFirst;
        comp.pSecond = pSecond;
        pFirst.on('down', () => selectHandler(id));
        pSecond.on('down', () => selectHandler(id));
        vec.on('down', () => selectHandler(id));

        comp.setAttribute = (attributes) => {
            pFirst.setAttribute(attributes);
            pSecond.setAttribute(attributes);
            vec.setAttribute(attributes);
        }
        comp.removeFromBoard = () => {
            board.removeObject(vec);
            board.removeObject(pFirst);
            board.removeObject(pSecond);
        };

        comp.getState = () => {
            return { type: comp.type, id: comp.id, coordsFirst: [pFirst.X(), pFirst.Y()], coordsSecond: [pSecond.X(), pSecond.Y()] };
        };

        comp.createOriginCopy = (board) => {
            var data = comp.getState();
            data.id = generateId();
            data.coordsFirst = [0, 0];
            data.coordsSecond = [pSecond.X() - pFirst.X(), pSecond.Y() - pFirst.Y()];
            return board.create(data.type, [data], {});
        }

        return comp;
    }

    JXG.createFlexVector = createFlexVector;
    JXG.registerElement('flexvector', JXG.createFlexVector);

    const createOriginVector = (board) => {
        return board.create("flexvector", [{ type: 'flexvector', id: generateId(), coordsFirst: [0, 0], coordsSecond: [2, 1] }], {});
    };

    /*board.create('flexline', [], {});*/
    /* creates a line through origin and [1, 1] */
    function createFlexLine(board, parents, attributes) {

        var lineState = parents[0];

        var id = lineState.id;
        const is_selected = () => state.selectedID == id;
        const dep_col = () => is_selected() ? Colors.blue : Colors.red;

        const coordsFirst = lineState.coordsFirst;
        const pFirstStyle = { withLabel: false, color: dep_col, showInfobox: true, infoboxDigits: 2, };
        const pSecondStyle = pFirstStyle;
        const lineStyle = { withLabel: false, strokeColor: dep_col, strokeWidth: 1, opacity: 0.75 };
        var pFirst = board.create('point', coordsFirst, { ...pFirstStyle });
        const coordsSecond = lineState.coordsSecond;
        var pSecond = board.create('point', coordsSecond, { ...pSecondStyle });
        var line = board.create('line', [pFirst, pSecond], { ...lineStyle });

        const comp = new JXG.Composition({});

        comp.type = lineState.type;
        comp.id = lineState.id;
        pFirst.on('down', () => selectHandler(id));
        pSecond.on('down', () => selectHandler(id));
        line.on('down', () => selectHandler(id));

        comp.setAttribute = (attributes) => {
            pFirst.setAttribute(attributes);
            pSecond.setAttribute(attributes);
            line.setAttribute(attributes);
        }
        comp.removeFromBoard = () => {
            board.removeObject(line);
            board.removeObject(pFirst);
            board.removeObject(pSecond);
        }

        comp.getState = () => {
            return { type: comp.type, id: comp.id, coordsFirst: [pFirst.X(), pFirst.Y()], coordsSecond: [pSecond.X(), pSecond.Y()] };
        };

        /* TODO: Probably always use left lower point of line for new origin... */
        comp.createOriginCopy = (board) => {
            var data = comp.getState();
            data.id = generateId();
            data.coordsFirst = [0, 0];
            data.coordsSecond = [pSecond.X() - pFirst.X(), pSecond.Y() - pFirst.Y()];
            return board.create(data.type, [data], {});
        }

        return comp;
    }

    JXG.createFlexLine = createFlexLine;
    JXG.registerElement('flexline', JXG.createFlexLine);

    const createOriginLine = (board) => {
        return board.create("flexline", [{ type: 'flexline', id: generateId(), coordsFirst: [0, 0], coordsSecond: [1, 1] }], {});
    };

    /*board.create('flexcircle', [radius], {});*/
    /* creates a circle with center in the origin and some radius */
    function createFlexCircle(board, parents, attributes) {

        const cState = parents[0];

        const id = cState.id;
        const radius = cState.radius;
        /*console.log('radius: ' + radius);*/

        const is_selected = () => state.selectedID == id;
        const dep_col = () => is_selected() ? Colors.blue : Colors.orange;
        const coordsOrigin = [0, 0];
        const pCenterStyle = { withLabel: false, fillColor: dep_col, strokeColor: dep_col, showInfobox: true, infoboxDigits: 2, };
        const pRadiusStyle = { withLabel: false, fillColor: dep_col, strokeColor: 'red', strokeWidth: 1, showInfobox: true, infoboxDigits: 2, };
        const circleStyle = { withLabel: false, strokeColor: dep_col, strokeWidth: 1, opacity: 0.75 };
        var pCenter = board.create('point', coordsOrigin, { ...pCenterStyle });
        const coordsRadius = [coordsOrigin[0] + Math.cos(Math.PI / 4) * radius, coordsOrigin[1] + Math.sin(Math.PI / 4) * radius];
        var pRadius = board.create('point', coordsRadius, { ...pRadiusStyle });
        var circle = board.create('circle', [pCenter, pRadius], { ...circleStyle });

        var group = board.create('group', [pCenter, pRadius]);
        group.removeTranslationPoint(pRadius);
        pCenter.moveTo(cState.coordsCenter);
        /*console.log('group id: ' + group.id);*/

        const comp = new JXG.Composition({});

        comp.type = cState.type;
        comp.id = cState.id;
        comp.pCenter = pCenter;
        comp.pRadius = pRadius;
        pCenter.on('down', () => selectHandler(id));
        pRadius.on('down', () => selectHandler(id));
        circle.on('down', () => selectHandler(id));

        pRadius.on('over', () => {
            board.highlightInfobox = function (x, y, el) {
                var nCart = { 'real': x, 'imag': y };
                var nPolar = convert2Polar(nCart);
                /*multiply with i, if y-axis has Re */
                if (pAxisLabelsData && pAxisLabelsData.Y() == 4) {
                    nPolar = { 'abs': nPolar.abs, 'angle': JXG.Math.mod(nPolar.angle - 90.0, 360) };
                }
                var r = nPolar.abs.toFixed(2);
                var phi = nPolar.angle.toFixed(2);
                var radius = JXG.Math.Geometry.distance([pCenter.X(), pCenter.Y()], [x, y], 2).toFixed(2);
                this.infobox.setText('<div style="font-size: 12px; color: grey; background-color: white; border-radius: 4px; border: 1px solid grey; text-align: center;"><span style="color: darkred; padding: 6px; white-space:nowrap;">Radius: ' + radius + '</span></div>');
            };
        });

        pRadius.on('out', () => {
            board.highlightInfobox = function (x, y, el) {
                var nCart = { 'real': x, 'imag': y };
                var nPolar = convert2Polar(nCart);
                /*multiply with i, if y-axis has Re */
                if (pAxisLabelsData && pAxisLabelsData.Y() == 4) {
                    nPolar = { 'abs': nPolar.abs, 'angle': JXG.Math.mod(nPolar.angle - 90.0, 360) };
                }
                var r = nPolar.abs.toFixed(2);
                var phi = nPolar.angle.toFixed(2);
                this.infobox.setText('<div style="font-size: 12px; color: grey; background-color: white; border-radius: 4px; border: 1px solid grey"><span style="color: black; padding: 2px; white-space:nowrap;">(x= ' + x + ', y= ' + y + ')</span><hr style="margin: 2px 0px; border-width: 1px;"><span style="color: blue; padding: 2px; white-space:nowrap;">(r= ' + r + ', &phi;= ' + phi + '&deg;)</span></div>');
            };
        });

        comp.computeRadius = () => {
            return JXG.Math.Geometry.distance([pCenter.X(), pCenter.Y()], [pRadius.X(), pRadius.Y()], 2);
        }
        comp.setAttribute = (attributes) => {
            pCenter.setAttribute(attributes);
            pRadius.setAttribute(attributes);
            circle.setAttribute(attributes);
        }
        comp.removeFromBoard = () => {
            board.removeObject(circle);
            board.removeObject(pCenter);
            board.removeObject(pRadius);

            /* TODO: the next 2 lines have no effect... */
            group.ungroup();
            board.removeObject(group);
        }

        comp.getState = () => {
            const pCenterCoords = [pCenter.X(), pCenter.Y()];
            const pRadiusCoords = [pRadius.X(), pRadius.Y()];
            return { type: comp.type, id: comp.id, coordsCenter: pCenterCoords, radius: JXG.Math.Geometry.distance(pCenterCoords, pRadiusCoords, 2) };
        };

        comp.createOriginCopy = (board) => {
            var data = comp.getState();
            data.id = generateId();
            data.coordsCenter = [0, 0];
            return board.create(data.type, [data], {});
        }

        return comp;
    }

    JXG.createFlexCircle = createFlexCircle;
    JXG.registerElement('flexcircle', JXG.createFlexCircle);

    const createOriginCircle = (board, radius) => {
        return board.create("flexcircle", [{ type: 'flexcircle', id: generateId(), coordsCenter: [0, 0], radius: radius }], {});
    };

    const createGeoObjectFromState = (board, gState) => {
        return board.create(gState.type, [gState], {});
    }

    const optionsText = '<option value="nochoice"></option><option value="-Im">-Im/cm</option><option value="-Re">-Re/cm</option><option value="Im">Im/cm</option><option value="Re">Re/cm</option>';
    const xmin = options.showStaticAsyncSOK ? -5 : -10;
    const xmax = options.showStaticAsyncSOK ? 16 : 11;
    const ymin = -8.5;
    const ymax = 12.5;
    const board = JXG.JSXGraph.initBoard(divid, {
        boundingbox: [xmin, ymax, xmax, ymin],
        axis: true,
        showCopyright: false,
        keepAspectRatio: true,
        defaultAxes: {
            x: {
                name: options.showStaticAsyncSOK ? '-Im/cm' : '<select name="xAxisChoice" id="xAxisChoice">' + optionsText + '</select>',
                withLabel: true,
                label: {
                    position: 'rt',
                    offset: options.showStaticAsyncSOK ? [-40, -30] : [-65, -30],
                    cssStyle: 'font-weight: bold;'
                },
                ticks: {
                    insertTicks: false, // Turn off automatic tick placing
                    minorTicks: 1,      // One minor tick between two major ticks
                    minorHeight: -1,    // Minor ticks are finitely long, too
                    ticksDistance: 1,    // Major ticks are positioned at multiples of one
                    //label: { fontSize: 12, display: 'html', cssClass: 'tickLabels' }
                }
            },
            y: {
                name: options.showStaticAsyncSOK ? 'Re/cm' : '<select name="yAxisChoice" id="yAxisChoice">' + optionsText + '</select>',
                withLabel: true,
                label: {
                    position: 'rt',
                    offset: options.showStaticAsyncSOK ? [-72, -5] : [-92, -5],
                    cssStyle: 'font-weight: bold;'
                },
                ticks: {
                    insertTicks: false, // Turn off automatic tick placing
                    minorTicks: 1,      // No minor ticks between major ticks
                    minorHeight: -1,
                    ticksDistance: 1,    // Major ticks are positioned at multiples of two
                    //label: { fontSize: 12, display: 'html', cssClass: 'tickLabels' }
                }
            }
        },
        zoom: {
            min: 1,
            max: 8
        },
    });


    /* Daten von STACK holen oder verbinden */
    var pAxisLabelsData = null;
    if (!options.showStaticAsyncSOK) {
        var initialChoices = document.getElementById(ansAxisLabelsRef).value;
        pAxisLabelsData = board.create('point', [0, 0], { visible: false, highlight: false, size: 0 });
        stack_jxg.bind_point(ansAxisLabelsRef, pAxisLabelsData);
        changeDropdownChoice('xAxisChoice', Math.round(pAxisLabelsData.X()));
        changeDropdownChoice('yAxisChoice', Math.round(pAxisLabelsData.Y()));

        document.addEventListener('change', (e) => {
            pAxisLabelsData.moveTo([document.getElementById('xAxisChoice').selectedIndex, document.getElementById('yAxisChoice').selectedIndex]);
        });
    }

    var pstyle = { name: '', snapToGrid: false, snapSizeX: 0.1, snapSizeY: 0.1, size: 4, showInfobox: false };

    board.highlightInfobox = function (x, y, el) {
        var nCart = { 'real': x, 'imag': y };
        var nPolar = convert2Polar(nCart);
        /*multiply with i, if y-axis has Re */
        if (pAxisLabelsData && pAxisLabelsData.Y() == 4) {
            nPolar = { 'abs': nPolar.abs, 'angle': JXG.Math.mod(nPolar.angle - 90.0, 360) };
        }
        var r = nPolar.abs.toFixed(2);
        var phi = nPolar.angle.toFixed(2);
        this.infobox.setText('<div style="font-size: 12px; color: grey; background-color: white; border-radius: 4px; border: 1px solid grey"><span style="color: black; padding: 2px; white-space:nowrap;">(x= ' + x + ', y= ' + y + ')</span><hr style="margin: 2px 0px; border-width: 1px;"><span style="color: blue; padding: 2px; white-space:nowrap;">(r= ' + r + ', &phi;= ' + phi + '&deg;)</span></div>');
    };



    const buttonStyle = { frozen: true };

    var addCircleButton = board.create('button', [xmin + 1, ymin + 1, 'Kreis', () => {
        const fCirc1 = createOriginCircle(board, 1);
        state.objMap.set(fCirc1.id, fCirc1);
    }], { ...buttonStyle });
    var addLineButton = board.create('button', [xmin + 3, ymin + 1, 'Gerade', () => {
        const fLine1 = createOriginLine(board);
        state.objMap.set(fLine1.id, fLine1);
    }], { ...buttonStyle });


    var addVectorButton = null;
    if (options.withVectorButton) {
        addVectorButton = board.create('button', [xmin + 5.6, ymin + 1, 'Vektor', () => {
            const fVec1 = createOriginVector(board);
            state.objMap.set(fVec1.id, fVec1);
        }], { ...buttonStyle });
    }




    var yBtnPos = ymax - 1;

    if (options.checkSOK) {
        sokCheckbox = board.create('checkbox', [xmax - 4, yBtnPos, "Stromortskurve"], { fixed: true, frozen: true });
        JXG.addEvent(sokCheckbox.rendNodeCheckbox, 'change', function () {
            if (this.Value()) {
                state.sokID = state.selectedID;
            }
        }, sokCheckbox);
        yBtnPos -= 1;
    }

    if (options.checkBP) {
        bpCheckbox = board.create('checkbox', [xmax - 4, yBtnPos, "Betriebspunkt"], { fixed: true, frozen: true });
        JXG.addEvent(bpCheckbox.rendNodeCheckbox, 'change', function () {
            if (this.Value()) {
                state.bpID = state.selectedID;
            }
        }, bpCheckbox);
        yBtnPos -= 1;
    }


    var copySelectedObjectButton = board.create('button', [xmax - 4, yBtnPos, 'Objekt kopieren', () => {
        if (state.selectedID) {

            const selectedObj = state.objMap.get(state.selectedID);
            const newObj = selectedObj.createOriginCopy(board);
            state.objMap.set(newObj.id, newObj);
        }
    }], { ...buttonStyle });
    yBtnPos -= 1;

    var removeSelectedObjectButton = board.create('button', [xmax - 4, yBtnPos, 'Objekt löschen', () => {
        if (state.selectedID) {
            state.objMap.get(state.selectedID).removeFromBoard();
            state.objMap.delete(state.selectedID);
            state.selectedID = null;
        }
    }], { ...buttonStyle });
    yBtnPos -= 1;



    /***************************************/
    /* Tape measure and angle measure */
    const col5 = 'black';

    var angleStyle = { radius: 0.8, orthoType: 'sector', strokeColor: 'none', withLabel: false };
    var angleLabelStyle = { fontSize: 15, cssStyle: 'font-family: MJXZERO, MJXTEX', fixed: true };

    var myAttractors = [];
    /*
    for(var i = -6; i < 7; i++) {
      if(i==0) continue;
      myAttractors.push(board.create('point', [i, 0], {size: 6, showInfobox: false, color: 'transparent', highlightColor: 'transparent', withLabel: false, fixed: true, highlight: false}));
      myAttractors.push(board.create('point', [0, i], {size: 6, showInfobox: false, color: 'transparent', highlightColor: 'transparent', withLabel: false, fixed: true, highlight: false}));
    }
    */
    var mpls = options.showStaticAsyncSOK ? [[10, -6.5], [15, -6.5], [13, -5], [10, -5], [11.5, -5]] : [[5, -6.5], [10, -6.5], [8, -5], [5, -5], [6.5, -5]];
    var tape = board.create('tapemeasure', [mpls[0], mpls[1]], { name: 'L', precision: options.tapePrecision });
    tape.point1.setAttribute({ ignoredSnapToPoints: [], attractorDistance: 5 });
    tape.point2.setAttribute({ ignoredSnapToPoints: [], attractorDistance: 5 });
    tape.label.setAttribute({ fontWeight: 'bold', strokeColor: 'white', cssStyle: 'backgroundColor: rgba(0, 0, 0, 0.7); padding: 3px' });

    const amPStyle = { showInfobox: false, withLabel: false, size: 6, strokeColor: col5, fillColor: 'transparent', highlightFillColor: 'transparent', attractors: myAttractors, attractorDistance: 0.7, snatchDistance: 0.7 };
    var amStart = board.create('point', mpls[2], { ...amPStyle });
    var amEnd = board.create('point', mpls[3], { ...amPStyle });
    var amCenter = board.create('point', mpls[4], { ...amPStyle });
    var amRightSeg = board.create('segment', [amStart, amCenter], { strokeColor: col5 });
    var amLeftSeg = board.create('segment', [amCenter, amEnd], { strokeColor: col5 });
    var angleMeasure = board.create('angle', [amStart, amCenter, amEnd], { label: { cssStyle: 'backgroundColor: rgba(0, 0, 0, 0.7); padding: 3px', strokeColor: 'white' }, fillColor: col5, strokeColor: col5, name: () => '&phi; = ' + JXG.Math.Geometry.trueAngle(amStart, amCenter, amEnd).toFixed(0) + '°' });
    var amGroup = board.create('group', [amStart, amCenter, amEnd]);
    amGroup.setTranslationPoints([amCenter]);
    /*Zeigerdiagramm*/
    if (options.withPhasorDiagram) {
        var col1 = JXG.paletteWong.blue;
        var col2 = JXG.paletteWong.red;
        var col3 = JXG.paletteWong.green;
        var collight1 = "rgba(0, 72, 178, 0.5)";
        var collight2 = "rgba(213, 94, 0, 0.5)";
        var collight3 = "rgba(0, 158, 115, 0.5)";
        const attDist = 0.3;
        const vecPointStyle = { color: "grey", size: 1, fixed: false, highlight: false, showInfobox: false, snapToGrid: false, snapToPoints: true, attractorDistance: attDist };
        const vecStyle = { withLabel: true, strokeWidth: 1, opacity: 0.75, lastArrow: { type: 2, size: 14 } };
        var pCoords = options.vecPositions;
        var ps = [];
        var vecs = [];
        var vecLabels = options.vecLabels;
        for (let i = 0, j = 0; i < pCoords.length; i++) {
            ps[i] = board.create("point", pCoords[i], { ...vecPointStyle, withLabel: false });
            if (i % 2 == 1) {
                vecs[j] = board.create("arrow", [ps[i - 1], ps[i]], { ...vecStyle, name: vecLabels[j], color: col1, label: { position: () => ps[i].X() <= 0 ? "lft" : "rt", color: "white", cssStyle: `background-color: ${collight1}; padding: 2px 4px; border-radius: 4px;` } });
                j = j + 1;
            }
        }
        var midpoints = [];
        var texts = [];
        for (let j = 0; j < vecs.length; j++) {
            midpoints[j] = board.create("midpoint", [vecs[j]], { size: 0, highlight: false, visible: false, withLabel: false });
            texts[j] = board.create("text", [() => midpoints[j].X(), () => midpoints[j].Y(), () => {
                var nCart = { 'real': vecs[j].point2.X() - vecs[j].point1.X(), 'imag': vecs[j].point2.Y() - vecs[j].point1.Y() };
                var nPolar = convert2Polar(nCart);
                /*multiply with i, if y-axis has Re */
                if (pAxisLabelsData && pAxisLabelsData.Y() == 4) {
                    nPolar = { 'abs': nPolar.abs, 'angle': JXG.Math.mod(nPolar.angle - 90.0, 360) };
                }
                var r = nPolar.abs.toFixed(1);
                var phi = nPolar.angle.toFixed(1);
                return r + " cm, " + phi + "&deg;";
            }], { visible: false, fontSize: 10, anchorX: 'middle', anchorY: 'middle', fontWeight: 'bold', strokeColor: 'white', cssStyle: 'backgroundColor: rgba(0, 0, 0, 0.7); padding: 3px' });
            ps[2 * j + 1].on("mouseover", () => { texts[j].setAttribute({ visible: true }); });
            ps[2 * j + 1].on("mouseout", () => { texts[j].setAttribute({ visible: false }); });
        }
        stack_jxg.bind_list_of(ansZDRef, ps);
    }


    const storedState = JSON.parse(document.getElementById(ansStateStorageRef).value);
    if (storedState != "" || (storedState && storedState.objMap == [])) {
        state.selectedID = storedState.selectedID;
        state.sokID = storedState.sokID;
        state.bpID = storedState.bpID;
        var createObjects = (value, key, map) => {
            map.set(key, createGeoObjectFromState(board, value));
        };
        var preparedState = new Map(storedState.objMap);
        preparedState.forEach(createObjects);
        state.objMap = preparedState;
        if ((state.sokID != "-1" || state.bpID != "-1") && state.selectedID) {
            if (sokCheckbox) sokCheckbox.rendNodeCheckbox.checked = state.selectedID == state.sokID;
            if (bpCheckbox) bpCheckbox.rendNodeCheckbox.checked = state.selectedID == state.bpID;
        }
    } else {
        /* do nothing */
    }


    const interpreteCoords = (coords, csystem) => {
        var m0 = -9999;
        var m1 = -9999;
        var c0 = csystem[0];
        var c1 = csystem[1];
        if (c0 == '-Im') {
            m0 = -coords[1];
        } else if (c0 == 'Im') {
            m0 = coords[1];
        } else if (c0 == '-Re') {
            m0 = -coords[0];
        } else if (c0 == 'Re') {
            m0 = coords[0];
        } else {
            /* do nothing */
        }

        if (c1 == '-Im') {
            m1 = -coords[1];
        } else if (c1 == 'Im') {
            m1 = coords[1];
        } else if (c1 == '-Re') {
            m1 = -coords[0];
        } else if (c1 == 'Re') {
            m1 = coords[0];
        } else {
            /* do nothing */
        }
        var mapped = [m0, m1];
        return mapped;
    };


    /* Muster-SOK anzeigen für x:=(-Im) und y:=Re */

    if (options.showStaticAsyncSOK) {

        const solPStyle = { color: 'darkred' };
        const solVecStyle = { strokeColor: Colors.purple, strokeWidth: 2 };
        const solHelperCircStyle = { visible: false, strokeColor: Colors.orange, strokeWidth: 1 };
        const solSOKStyle = { strokeColor: Colors.blue, strokeWidth: 3 };
        const solLineStyle = { visible: false, strokeColor: 'black', strokeWidth: 2 };
        var p_Inenn_coords = interpreteCoords([options.xInenncm, options.yInenncm], ['-Im', 'Re']);
        var vec_Inenn = board.create("arrow", [[0, 0], p_Inenn_coords], { ...solVecStyle });
        var p_Istill_coords = interpreteCoords([options.xIstillcm, options.yIstillcm], ['-Im', 'Re']);
        var vec_Istill = board.create("arrow", [[0, 0], p_Istill_coords], { ...solVecStyle });
        const helper_circ_radius = Math.max(Math.abs(p_Istill_coords[0]), Math.abs(p_Inenn_coords[0]));
        var helper_circ_Istill = board.create('circle', [p_Istill_coords, helper_circ_radius], { ...solHelperCircStyle });
        var helper_circ_Inenn = board.create('circle', [p_Inenn_coords, helper_circ_radius], { ...solHelperCircStyle });
        var p_Istill = board.create('point', p_Istill_coords, { ...solPStyle, name: 's=1', withLabel: true, showInfobox: false });
        var p_Inenn = board.create('point', p_Inenn_coords, { ...solPStyle, name: 's=s<sub>N</sub>', withLabel: true, showInfobox: false, label: { anchorX: 'right', anchorY: 'bottom' } });
        var line_Inenn_Istill = board.create('line', [p_Istill, p_Inenn], { ...solLineStyle, strokeWidth: 1 });
        var midp_Inenn_Istill = board.create('midpoint', [p_Istill, p_Inenn], { visible: false, ...solPStyle });
        var line_perp = board.create('perpendicular', [line_Inenn_Istill, midp_Inenn_Istill], { ...solLineStyle });
        var center_SOK = board.create('intersection', [board.defaultAxes.x, line_perp], { ...solPStyle, color: Colors.blue });
        var radius_SOK = JXG.Math.Geometry.distance(p_Istill_coords, [center_SOK.X(), center_SOK.Y()], 2);
        var circ_SOK = board.create('circle', [center_SOK, radius_SOK], { ...solSOKStyle });

        var musterElements = [vec_Inenn, vec_Istill, helper_circ_Istill, helper_circ_Inenn, p_Istill, p_Inenn, line_Inenn_Istill, midp_Inenn_Istill, line_perp, center_SOK, circ_SOK];
        for (let i = 0; i < musterElements.length; i++) {
            musterElements[i].setAttribute({ fixed: true, strokeOpacity: 0.7, fillOpacity: 0.7, highlight: false });
        }

    }





    /* TODO: Muster-SOK durch Checkbox anzeigen für x:=(-Im) und y:=Re */
    /*
    const solPStyle = {color: 'darkred'};
    const solVecStyle = {strokeColor: Colors.purple, strokeWidth: 2};
    const solHelperCircStyle = {strokeColor: Colors.orange, strokeWidth: 1};
    const solSOKStyle = {strokeColor: Colors.blue, strokeWidth: 3};
    const solLineStyle = {strokeColor: 'black', strokeWidth: 2};
    var p_Inenn_coords = interpreteCoords([{#xInenncm#}, {#yInenncm#}], ['-Im', 'Re']);
    var vec_Inenn = board.create("arrow", [[0, 0], p_Inenn_coords], {...solVecStyle});
    var p_Istill_coords = interpreteCoords([{#xIstillcm#}, {#yIstillcm#}], ['-Im', 'Re']);
    var vec_Istill = board.create("arrow", [[0, 0], p_Istill_coords], {...solVecStyle});
    const helper_circ_radius = Math.max(Math.abs(p_Istill_coords[0]), Math.abs(p_Inenn_coords[0]));
    var helper_circ_Istill = board.create('circle', [p_Istill_coords, helper_circ_radius], {...solHelperCircStyle});
    var helper_circ_Inenn = board.create('circle', [p_Inenn_coords, helper_circ_radius], {...solHelperCircStyle});
    var p_Istill = board.create('point', p_Istill_coords, {...solPStyle});
    var p_Inenn = board.create('point', p_Inenn_coords, {...solPStyle});
    var line_Inenn_Istill = board.create('line', [p_Istill, p_Inenn], {...solLineStyle, strokeWidth: 1});
    var midp_Inenn_Istill = board.create('midpoint', [p_Istill, p_Inenn], {...solPStyle});
    var line_perp = board.create('perpendicular', [line_Inenn_Istill, midp_Inenn_Istill], {...solLineStyle});
    var center_SOK = board.create('intersection', [board.defaultAxes.x, line_perp], {...solPStyle});
    var radius_SOK = JXG.Math.Geometry.distance(p_Istill_coords, [center_SOK.X(), center_SOK.Y()], 2);
    var circ_SOK = board.create('circle', [center_SOK, radius_SOK], {...solSOKStyle}); 
    
    var musterElements = [vec_Inenn, vec_Istill, helper_circ_Istill, helper_circ_Inenn, p_Istill, p_Inenn, line_Inenn_Istill, midp_Inenn_Istill, line_perp, center_SOK, circ_SOK];
    
    const showSolutionCB = board.create("checkbox", [xmax-8.5, ymin+1.5, "Lösung anzeigen (x= - Im, y= Re)"], {fixed: true, frozen: true});
    showSolutionCB.rendNodeCheckbox.checked = false;
    for(let i = 0; i < musterElements.length; i++) {
      musterElements[i].setAttribute({visible: false, fixed: true, strokeOpacity: 0.7, fillOpacity: 0.7, highlight: false});
    }
    JXG.addEvent(showSolutionCB.rendNodeCheckbox, 'change', function() {
      for(let i = 0; i < musterElements.length; i++) {
        musterElements[i].setAttribute({visible: this.Value()});
      }
    }, showSolutionCB);
    */

    function storeState() {
        /*console.log("storeState");*/
        if (state.sokID !== "-1") {
            /*console.log("sokID is not -1");*/
            var currentSOK = state.objMap.get(state.sokID);
            if (currentSOK) {
                const type = currentSOK.type;
                var coordsCenter = null;
                var radius = -1;
                if (type === "flexcircle") {
                    coordsCenter = [currentSOK.pCenter.X(), currentSOK.pCenter.Y()];
                    radius = currentSOK.computeRadius();
                }
                changeValue(ansSOKRef, JSON.stringify([type, coordsCenter, radius]));
            }
        } else if (options.checkSOK) {
            changeValue(ansSOKRef, JSON.stringify(["-1", [], -1]));
        }

        if (state.bpID !== "-1") {
            /*console.log("bpID is not -1");*/
            var currentBP = state.objMap.get(state.bpID);
            if (currentBP) {
                const type = currentBP.type;
                var coordsStart = null;
                var coordsEnd = null;
                /*console.log("type: " + type);*/
                if (type === "flexvector") {
                    coordsStart = [currentBP.pFirst.X(), currentBP.pFirst.Y()];
                    coordsEnd = [currentBP.pSecond.X(), currentBP.pSecond.Y()];
                    /*console.log(currentBP);*/
                }
                changeValue(ansBPRef, JSON.stringify([type, coordsStart, coordsEnd]));
            }
        } else if (options.checkBP) {
            changeValue(ansBPRef, JSON.stringify(["-1", [], []]));
        }


        var preparedStateMap = new Map(state.objMap);
        var processElements = (value, key, map) => {
            map.set(key, value.getState());
        }
        preparedStateMap.forEach(processElements);
        var preparedStateMapAsArray = Array.from(preparedStateMap);
        var prepState = {
            objMap: preparedStateMapAsArray,
            selectedID: state.selectedID,
            sokID: state.sokID,
            bpID: state.bpID,
        }
        changeValue(ansStateStorageRef, JSON.stringify(prepState));
    }

    board.on('update', storeState);


}; /* end of createConstructionBoard body */
/*********************************************/

createConstructionBoard(params);

[[/jsxgraph]]

<div hidden>[[input:ansZDAxisLabels]] [[validation:ansZDAxisLabels]]</div>
<div hidden>[[input:ansZD]] [[validation:ansZD]]</div>
<div hidden>[[input:ansZDStateStorage]] [[validation:ansZDStateStorage]]</div>

[[feedback:prtZD]]



[[if test="is(debugMode)"]]
<details class="ideal-debug"><summary>Debug-Informationen</summary>
[[ debug /]]
</details>
[[/if]]

<p>&nbsp;</p>]]></text>
    </questiontext>
    <generalfeedback format="html">
      <text></text>
    </generalfeedback>
    <defaultgrade>1</defaultgrade>
    <penalty>0.1</penalty>
    <hidden>0</hidden>
    <idnumber></idnumber>
    <stackversion>
      <text>2023121100</text>
    </stackversion>
    <questionvariables>
      <text><![CDATA[/* Created by Johannes Knaut, OTH Amberg-Weiden */
/* With requirements from Prof. Dr. Heiko Zatocil, OTH Amberg-Weiden */

/* Im Einsatz immer auf false stellen, sonst sehen die Studis Debug-Informationen */
debugMode: false;

/* Funktion zur Interpretation von Koordinaten je nach Achsenbeschriftung */
interpreteCoords(coords, csystem):=block(m1: -9999, m2: -9999, c1: csystem[1], c2: csystem[2], m1: if is(c1=1) then -coords[2] elseif is(c1=3) then coords[2] elseif is(c1=2) then -coords[1] else coords[1], m2: if is(c2=1) then -coords[2] elseif is(c2=3) then coords[2] elseif is(c2=2) then -coords[1] else coords[1], mapped: [m1, m2], return(mapped));

/*************/
/*Zweipolig!!*/

/*Scheinleistung im Nennbetrieb in VA*/
SN_MVA: 250; /* MVA */
SN_VA: 1000 * 1000 * SN_MVA; /* VA */

/*Nenneffektivwert der Spannung in V*/
UN_kVY: 138/10; /*kV(Y)*/
UN_VY: 1000 * UN_kVY; /*V(Y)*/
UN_kVY_disp: decimalplaces(UN_kVY, 1); /*z.B. 13.8*/

/*Leistungsfaktor*/
cosphi: -8/10; /*(übererregt)*/
cosphi_disp: decimalplaces(cosphi, 1); /*z.B. -0.8*/

/*Bezogene Streureaktanz*/
xsigma: 2/10; /*p.u.*/
xsigma_disp: decimalplaces(xsigma, 1); /*z.B. 0.2*/

/*I_N: Nennwert des Primär-/Statorstroms in A*/
/*I_k0: Kurzschlusstrom in A*/
INk0_by_IN: 63/100; /*ohne Einheit*/
INk0_by_IN_disp: decimalplaces(INk0_by_IN, 2);

/*TEILAUFGABE 1*/
/*Nennleistung: P_N = S_N \cdot cos_phi*/
PN_MW: SN_MVA * cosphi; /*MW*/

/*Nennstrom: S_N = \sqrt(3) \cdot U_N \cdot I_N*/
IN_A: SN_VA / (sqrt(3) * UN_VY); /*A*/

/*Synchronreaktanz*/
Xd_Ohm: UN_VY / (sqrt(3) * INk0_by_IN * IN_A); /*Ohm*/

/*Streureaktanz*/
ZN_Ohm: UN_VY / (sqrt(3) * IN_A); /*Ohm*/
Xsigma_Ohm: 2/10 * ZN_Ohm; /*Ohm*/
Xh_Ohm: Xd_Ohm - Xsigma_Ohm; /*Ohm*/

/*TEILAUFGABE 2*/
/*Massstab*/
mI_Abycm: 2000; /*A/cm*/

/*Induktiver Strom*/
UN_by_Xdsqrt3_A: UN_VY / (sqrt(3) * Xd_Ohm);
UN_by_Xdsqrt3_cm: UN_by_Xdsqrt3_A / mI_Abycm; /*cm*/

/*Nennstrom*/
IN_cm: IN_A / mI_Abycm; /*cm*/

/*Nennstromwinkel*/
phiN: acos(cosphi);
phiN_Grad: phiN / %pi * 180; /*Grad*/

/*Zeichnerisch: Die Länge U_PN / X_d aus Stromortskurve ablesen und umrechnen in kA*/
/*Rechnerisch: Mit Kosinussatz c^2 = a^2 + b^2 - 2 \cdot a \cdot b \cdot \cos(\gamma) */
UPN_by_Xd_cm: sqrt(UN_by_Xdsqrt3_cm^2 + IN_cm^2 - 2 * UN_by_Xdsqrt3_cm * IN_cm * cos(3/2*%pi-phiN));
UPN_by_Xd_A: UPN_by_Xd_cm * mI_Abycm; /*A*/

/* Loesung fuer SOK */
expected_sok_type: "flexcircle";
taSOKCenter: [0, -float(UN_by_Xdsqrt3_cm)];
taSOKRadius: float(UPN_by_Xd_cm);
taSOK: [expected_sok_type, taSOKCenter, taSOKRadius];

/*Zeichnerisch: Den Winkel theta_LN aus Stromortskurve ablesen*/
/*Rechnerisch: Mit Sinussatz*/
thetaLN: asin(IN_cm / UPN_by_Xd_cm * sin(3/2*%pi-phiN));
thetaLN_Grad: thetaLN / %pi * 180; /*Grad*/

/*Polradspannung*/
UPN_V: UPN_by_Xd_A * Xd_Ohm; /*V*/
UPN_kV: UPN_V / 1000; /*kV*/

/*Fiktiver Erregernennstrom*/
IstrichEN_A: UPN_V / Xh_Ohm; /*A*/
IstrichEN_kA: IstrichEN_A / 1000; /*kA*/

/*TEILAUFGABE 3*/
S_MVA: 220; /*MVA*/
S_VA: 1000 * 1000 * S_MVA; /*VA*/
cosphiS: -0.7;

/*Ständerstrom*/
I_A: S_VA / (sqrt(3) * UN_VY); /*A*/
I_cm: I_A / mI_Abycm; /*cm*/

/*Stromwinkel*/
phiS: acos(cosphiS);
phiS_Grad: phiS / %pi * 180; /*Grad*/

/*Zeicherisch IstrichE_A */
/*Zeichnerisch 1: Ablesen der Länge zwischen Betriebspunkt und Enpunkt des induktiven Stroms*/
/*Zeichnerisch 2: Abgelesene Länge / UPN_by_Xd_cm * IstrichEN_A */
/*Rechnerisch IstrichE_A */
/*Rechnerisch: Wieder mit Kosinussatz*/
Istrich_cm: sqrt(UN_by_Xdsqrt3_cm^2 + I_cm^2 - 2 * UN_by_Xdsqrt3_cm * I_cm * cos(3/2*%pi-phiS));
IstrichE_A: Istrich_cm / UPN_by_Xd_cm * IstrichEN_A; /*A*/
IstrichE_kA: IstrichE_A / 1000; /*kA*/

/*Loesungen*/
taPN: decimalplaces(PN_MW, 0);
taIN: decimalplaces(IN_A, 0);
taXd: decimalplaces(Xd_Ohm, 3);
taXsigma: decimalplaces(Xsigma_Ohm, 3);
taXh: decimalplaces(Xh_Ohm, 3);

taThetaLN: decimalplaces(thetaLN_Grad, 1);
taUPN: decimalplaces(UPN_kV, 1);
taIENFiktiv: decimalplaces(IstrichEN_kA, 1);
bpComplex: I_cm * %e^(%i*(phiS));
bpCoords: float([realpart(bpComplex), imagpart(bpComplex)]);
taBP: ["flexvector", [0, 0], bpCoords];

taStateStorageDefault: "{'objMap':[],'selectedID':null,'sokID':'-1','bpID':'-1'}";
taStateStorage: sconcat("{\"objMap\":[[\"id0084b3c4158d1\",{\"type\":\"flexcircle\",\"id\":\"id0084b3c4158d1\",\"coordsCenter\":", interpreteCoords(taSOKCenter,[1,4]), ",\"radius\":", taSOKRadius,"}],[\"idff16c04b3464f8\",{\"type\":\"flexvector\",\"id\":\"idff16c04b3464f8\",\"coordsFirst\":[0,0],\"coordsSecond\":[-3.28653346969,-3.22144715417]}]],\"selectedID\":\"idff16c04b3464f8\",\"sokID\":\"id0084b3c4158d1\",\"bpID\":\"idff16c04b3464f8\"}");

taddBzYesNo: [[1, true, "Ja"], [2, false, "Nein"]];
taBzYesNo: first(mcq_correct(taddBzYesNo));
taBzReason: "Betriebspunkt zulässig da innerhalb des erlaubten Strombereichs der Stromortskurve."
taIstrichE: decimalplaces(IstrichE_kA, 1);

/*Globale Hilfsvariablen*/
aTol: 0.5001;



/*Zeigerdiagramm*/

/*Spannungs-Maßstab*/
mU_Vbycm: float(ZN_Ohm * mI_Abycm);

I1_cx: float(I_A * %e^(%i*phiS));

U1_VY: decimalplaces(UN_VY / sqrt(3), 2);
U1cart_ZD: interpreteCoords([U1_VY/mU_Vbycm,0],[4,3]);

I1cart_ZD: interpreteCoords(bpCoords,[4,3]);

jXSigi: %i * xsigma * I1_cx;
jXSigi_ZD: interpreteCoords([realpart(jXSigi)/mU_Vbycm, imagpart(jXSigi)/mU_Vbycm], [4, 3]);

jXHi: %i * Xh_Ohm * I1_cx;
jXHi_ZD: interpreteCoords([realpart(jXHi)/mU_Vbycm, imagpart(jXHi)/mU_Vbycm], [4, 3]);

jXdi: %i * Xd_Ohm * I1_cx;
jXdi_ZD: interpreteCoords([realpart(jXdi)/mU_Vbycm, imagpart(jXdi)/mU_Vbycm], [4, 3]);

URcart_ZD: U1cart_ZD - jXSigi_ZD;

/*Polradspannung*/
UPcart_ZD: URcart_ZD - jXHi_ZD;

UR_cx: interpreteCoords(URcart_ZD,[4,3])[1] + interpreteCoords(URcart_ZD,[4,3])[2] * %i;

/*TODO: hier besser zeichnerisch versuchen, Ungenauigkeit evtl. wegen vernachlaessigtem R? */
Imu_cx: UR_cx / (%i * Xh_Ohm) * (mU_Vbycm / mI_Abycm);
Imu_ZD: interpreteCoords([realpart(Imu_cx), imagpart(Imu_cx)], [4, 3]);


vecLabels: ["\\(\\underline{U}_1\\)", "\\(\\underline{I}_1\\)", "\\(\\underline{U}_P\\)", "\\(\\underline{I}_{\\mu}\\)", "\\(\\underline{I}'_E\\)", "\\(\\underline{U}_r\\)", "\\(-j X_{1\\sigma} \\cdot \\underline{I}_1\\)", "\\(-j X_h \\cdot \\underline{I}_1\\)"];

taZD: float([[0,0],U1cart_ZD,[0,0],I1cart_ZD,[0,0],UPcart_ZD,[0,0],Imu_ZD,I1cart_ZD,Imu_ZD,[0,0],URcart_ZD,U1cart_ZD,URcart_ZD,URcart_ZD,UPcart_ZD]);

taZDMuster: float([[0,0],interpreteCoords(U1cart_ZD,[1,4]),
[0,0],interpreteCoords(I1cart_ZD,[1,4]),
[0,0],interpreteCoords(UPcart_ZD,[1,4]),
[0,0],interpreteCoords(Imu_ZD,[1,4]),
interpreteCoords(I1cart_ZD,[1,4]),interpreteCoords(Imu_ZD,[1,4]),
[0,0],interpreteCoords(URcart_ZD,[1,4]),
interpreteCoords(U1cart_ZD,[1,4]),interpreteCoords(URcart_ZD,[1,4]),
interpreteCoords(URcart_ZD,[1,4]),interpreteCoords(UPcart_ZD,[1,4])]);]]></text>
    </questionvariables>
    <specificfeedback format="html">
      <text></text>
    </specificfeedback>
    <questionnote>
      <text><![CDATA[U_Maßstab: {@mU_Vbycm@}<br>
I_Maßstab: {@mI_Abycm@}<br>]]></text>
    </questionnote>
    <questiondescription format="html">
      <text></text>
    </questiondescription>
    <questionsimplify>1</questionsimplify>
    <assumepositive>0</assumepositive>
    <assumereal>0</assumereal>
    <prtcorrect format="html">
      <text><![CDATA[<p><span style="font-size: 1.5em; color:green;"><i class="fa fa-check"></i></span>&nbsp;Ihre Antwort ist richtig.</p>]]></text>
    </prtcorrect>
    <prtpartiallycorrect format="html">
      <text><![CDATA[<p><span style="font-size: 1.5em; color:orange;"><i class="fa fa-adjust"></i></span>&nbsp;Ihre Antwort ist teilweise korrekt.</p>]]></text>
    </prtpartiallycorrect>
    <prtincorrect format="html">
      <text>Falsche Antwort.</text>
    </prtincorrect>
    <decimals>.</decimals>
    <multiplicationsign>dot</multiplicationsign>
    <sqrtsign>1</sqrtsign>
    <complexno>i</complexno>
    <inversetrig>cos-1</inversetrig>
    <logicsymbol>lang</logicsymbol>
    <matrixparens>[</matrixparens>
    <variantsselectionseed></variantsselectionseed>
    <input>
      <name>ansAxisLabels</name>
      <type>algebraic</type>
      <tans>[1,4]</tans>
      <boxsize>15</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint></syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>1</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>0</mustverify>
      <showvalidation>0</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansBP</name>
      <type>algebraic</type>
      <tans>taBP</tans>
      <boxsize>15</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint><![CDATA[["-1", [], []]]]></syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>0</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>0</mustverify>
      <showvalidation>0</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansBzReason</name>
      <type>string</type>
      <tans>taBzReason</tans>
      <boxsize>45</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint>Kurze Begründung eingeben...</syntaxhint>
      <syntaxattribute>1</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>0</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>0</mustverify>
      <showvalidation>0</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansBzYesNo</name>
      <type>dropdown</type>
      <tans>taddBzYesNo</tans>
      <boxsize>15</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint></syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>1</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>0</mustverify>
      <showvalidation>0</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansIENFiktiv</name>
      <type>numerical</type>
      <tans>taIENFiktiv</tans>
      <boxsize>5</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint></syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>0</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>1</mustverify>
      <showvalidation>3</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansIN</name>
      <type>numerical</type>
      <tans>taIN</tans>
      <boxsize>5</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint></syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>0</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>1</mustverify>
      <showvalidation>3</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansIstrichE</name>
      <type>numerical</type>
      <tans>taIstrichE</tans>
      <boxsize>5</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint></syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>0</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>1</mustverify>
      <showvalidation>3</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansPN</name>
      <type>numerical</type>
      <tans>taPN</tans>
      <boxsize>5</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint></syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>0</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>1</mustverify>
      <showvalidation>3</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansSOK</name>
      <type>algebraic</type>
      <tans>taSOK</tans>
      <boxsize>15</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint><![CDATA[["-1", [], -1]]]></syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>0</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>0</mustverify>
      <showvalidation>0</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansStateStorage</name>
      <type>string</type>
      <tans>taStateStorage</tans>
      <boxsize>15</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint><![CDATA[""]]></syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>1</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>0</mustverify>
      <showvalidation>0</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansThetaLN</name>
      <type>algebraic</type>
      <tans>taThetaLN</tans>
      <boxsize>5</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint></syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords>°, Grad</forbidwords>
      <allowwords></allowwords>
      <forbidfloat>0</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>1</mustverify>
      <showvalidation>3</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansUPN</name>
      <type>numerical</type>
      <tans>taUPN</tans>
      <boxsize>5</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint></syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>0</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>1</mustverify>
      <showvalidation>3</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansXd</name>
      <type>numerical</type>
      <tans>taXd</tans>
      <boxsize>5</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint></syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>0</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>1</mustverify>
      <showvalidation>3</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansXh</name>
      <type>numerical</type>
      <tans>taXh</tans>
      <boxsize>5</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint></syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>0</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>1</mustverify>
      <showvalidation>3</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansXsigma</name>
      <type>numerical</type>
      <tans>taXsigma</tans>
      <boxsize>5</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint></syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>0</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>1</mustverify>
      <showvalidation>3</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansZD</name>
      <type>algebraic</type>
      <tans>taZDMuster</tans>
      <boxsize>15</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint>[[-9,11],[-6,11],[-9,10],[-6,10],[-9,9],[-6,9],[-9,8],[-6,8],[-9,7],[-6,7],[-9,6],[-6,6],[-9,5],[-6,5],[-9,4],[-6,4]]</syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>0</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>0</mustverify>
      <showvalidation>0</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansZDAxisLabels</name>
      <type>algebraic</type>
      <tans>[1,4]</tans>
      <boxsize>15</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint></syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>1</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>0</mustverify>
      <showvalidation>0</showvalidation>
      <options></options>
    </input>
    <input>
      <name>ansZDStateStorage</name>
      <type>string</type>
      <tans><![CDATA[""]]></tans>
      <boxsize>15</boxsize>
      <strictsyntax>1</strictsyntax>
      <insertstars>0</insertstars>
      <syntaxhint><![CDATA[""]]></syntaxhint>
      <syntaxattribute>0</syntaxattribute>
      <forbidwords></forbidwords>
      <allowwords></allowwords>
      <forbidfloat>1</forbidfloat>
      <requirelowestterms>0</requirelowestterms>
      <checkanswertype>0</checkanswertype>
      <mustverify>0</mustverify>
      <showvalidation>0</showvalidation>
      <options></options>
    </input>
    <prt>
      <name>prtBP</name>
      <value>1.0000000</value>
      <autosimplify>1</autosimplify>
      <feedbackstyle>1</feedbackstyle>
      <feedbackvariables>
        <text><![CDATA[axisLabelsIncomplete: member(0, ansAxisLabels);
axisLabelsValid: not(axisLabelsIncomplete);

strictTol: 0.18;
relativeTol: 0.3; /* 5 Prozent Abweichung erlauben */
studentBPType: ansBP[1];
studentBPFirst: ansBP[2];
studentBPSecond: ansBP[3];

teacherBPFirst: interpreteCoords([0, 0], ansAxisLabels);
teacherBPSecond: interpreteCoords(bpCoords, ansAxisLabels);

bpWasChosen: not(studentBPType="-1");
bpValidType: is(studentBPType="flexvector");

bpCorrectFirst: is(ATNumAbsolute(studentBPFirst, teacherBPFirst, strictTol)[2]);
bpCorrectSecond: is(ATNumAbsolute(studentBPSecond, teacherBPSecond, strictTol)[2]);]]></text>
      </feedbackvariables>
      <node>
        <name>0</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>axisLabelsValid</sans>
        <tans>true</tans>
        <testoptions>0.5001</testoptions>
        <quiet>1</quiet>
        <truescoremode>+</truescoremode>
        <truescore>0</truescore>
        <truepenalty></truepenalty>
        <truenextnode>1</truenextnode>
        <trueanswernote>prtBP-1-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtBP-1-F</falseanswernote>
        <falsefeedback format="html">
          <text><![CDATA[<p>Bitte beschriften Sie beide Koordinatenachsen.</p>]]></text>
        </falsefeedback>
      </node>
      <node>
        <name>1</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>bpWasChosen</sans>
        <tans>true</tans>
        <testoptions></testoptions>
        <quiet>1</quiet>
        <truescoremode>+</truescoremode>
        <truescore>0</truescore>
        <truepenalty></truepenalty>
        <truenextnode>2</truenextnode>
        <trueanswernote>prtBP-2-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtBP-2-F</falseanswernote>
        <falsefeedback format="html">
          <text><![CDATA[<p>Sie haben noch kein geometrisches Objekt als Betriebspunkt markiert.</p>]]></text>
        </falsefeedback>
      </node>
      <node>
        <name>2</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>bpValidType</sans>
        <tans>true</tans>
        <testoptions></testoptions>
        <quiet>1</quiet>
        <truescoremode>+</truescoremode>
        <truescore>0.2</truescore>
        <truepenalty></truepenalty>
        <truenextnode>3</truenextnode>
        <trueanswernote>prtBP-3-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtBP-3-F</falseanswernote>
        <falsefeedback format="html">
          <text><![CDATA[<p>Stellen Sie den Betriebspunkt als Ortsvektor dar.</p>]]></text>
        </falsefeedback>
      </node>
      <node>
        <name>3</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>bpCorrectFirst</sans>
        <tans>true</tans>
        <testoptions>0.3001</testoptions>
        <quiet>1</quiet>
        <truescoremode>+</truescoremode>
        <truescore>0.4</truescore>
        <truepenalty></truepenalty>
        <truenextnode>4</truenextnode>
        <trueanswernote>prtBP-4-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtBP-4-F</falseanswernote>
        <falsefeedback format="html">
          <text><![CDATA[<p>Bei der Darstellung des Betriebspunktes muss der Vektor vom Ursprung ausgehen.</p>]]></text>
        </falsefeedback>
      </node>
      <node>
        <name>4</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>bpCorrectSecond</sans>
        <tans>true</tans>
        <testoptions>0.3001</testoptions>
        <quiet>1</quiet>
        <truescoremode>+</truescoremode>
        <truescore>0.4</truescore>
        <truepenalty></truepenalty>
        <truenextnode>-1</truenextnode>
        <trueanswernote>prtBP-5-T</trueanswernote>
        <truefeedback format="html">
          <text><![CDATA[<p>Sie haben den Betriebspunkt richtig eingezeichnet.</p>]]></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtBP-5-F</falseanswernote>
        <falsefeedback format="html">
          <text><![CDATA[<p>Sie haben den Betriebspunkt nicht richtig eingezeichnet.</p>]]></text>
        </falsefeedback>
      </node>
    </prt>
    <prt>
      <name>prtBzReason</name>
      <value>0.0000000</value>
      <autosimplify>1</autosimplify>
      <feedbackstyle>0</feedbackstyle>
      <feedbackvariables>
        <text>mansBzReason: ansBzReason;</text>
      </feedbackvariables>
      <node>
        <name>0</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>ansBzYesNo</sans>
        <tans>taBzYesNo</tans>
        <testoptions></testoptions>
        <quiet>1</quiet>
        <truescoremode>=</truescoremode>
        <truescore>1</truescore>
        <truepenalty></truepenalty>
        <truenextnode>-1</truenextnode>
        <trueanswernote>prtBzReason-1-T</trueanswernote>
        <truefeedback format="html">
          <text><![CDATA[<details><summary><b>Aufdecken</b></summary>
{@taBzReason@}
</details>]]></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtBzReason-1-F</falseanswernote>
        <falsefeedback format="html">
          <text></text>
        </falsefeedback>
      </node>
    </prt>
    <prt>
      <name>prtBzYesNo</name>
      <value>1.0000000</value>
      <autosimplify>1</autosimplify>
      <feedbackstyle>2</feedbackstyle>
      <feedbackvariables>
        <text></text>
      </feedbackvariables>
      <node>
        <name>0</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>ansBzYesNo</sans>
        <tans>taBzYesNo</tans>
        <testoptions></testoptions>
        <quiet>1</quiet>
        <truescoremode>=</truescoremode>
        <truescore>1</truescore>
        <truepenalty></truepenalty>
        <truenextnode>-1</truenextnode>
        <trueanswernote>prtBzYesNo-1-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtBzYesNo-1-F</falseanswernote>
        <falsefeedback format="html">
          <text></text>
        </falsefeedback>
      </node>
    </prt>
    <prt>
      <name>prtIENFiktiv</name>
      <value>1.0000000</value>
      <autosimplify>1</autosimplify>
      <feedbackstyle>2</feedbackstyle>
      <feedbackvariables>
        <text></text>
      </feedbackvariables>
      <node>
        <name>0</name>
        <description></description>
        <answertest>NumAbsolute</answertest>
        <sans>ansIENFiktiv</sans>
        <tans>taIENFiktiv</tans>
        <testoptions>aTol</testoptions>
        <quiet>1</quiet>
        <truescoremode>=</truescoremode>
        <truescore>1</truescore>
        <truepenalty></truepenalty>
        <truenextnode>-1</truenextnode>
        <trueanswernote>prtIENFiktiv-1-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtIENFiktiv-1-F</falseanswernote>
        <falsefeedback format="html">
          <text></text>
        </falsefeedback>
      </node>
    </prt>
    <prt>
      <name>prtIN</name>
      <value>1.0000000</value>
      <autosimplify>1</autosimplify>
      <feedbackstyle>2</feedbackstyle>
      <feedbackvariables>
        <text></text>
      </feedbackvariables>
      <node>
        <name>0</name>
        <description></description>
        <answertest>NumAbsolute</answertest>
        <sans>ansIN</sans>
        <tans>taIN</tans>
        <testoptions>50.001</testoptions>
        <quiet>1</quiet>
        <truescoremode>=</truescoremode>
        <truescore>1</truescore>
        <truepenalty></truepenalty>
        <truenextnode>-1</truenextnode>
        <trueanswernote>prtIN-1-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtIN-1-F</falseanswernote>
        <falsefeedback format="html">
          <text></text>
        </falsefeedback>
      </node>
    </prt>
    <prt>
      <name>prtIstrichE</name>
      <value>1.0000000</value>
      <autosimplify>1</autosimplify>
      <feedbackstyle>2</feedbackstyle>
      <feedbackvariables>
        <text></text>
      </feedbackvariables>
      <node>
        <name>0</name>
        <description></description>
        <answertest>NumAbsolute</answertest>
        <sans>ansIstrichE</sans>
        <tans>taIstrichE</tans>
        <testoptions>0.5001</testoptions>
        <quiet>1</quiet>
        <truescoremode>=</truescoremode>
        <truescore>1</truescore>
        <truepenalty></truepenalty>
        <truenextnode>-1</truenextnode>
        <trueanswernote>prtIstrichE-1-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtIstrichE-1-F</falseanswernote>
        <falsefeedback format="html">
          <text></text>
        </falsefeedback>
      </node>
    </prt>
    <prt>
      <name>prtPN</name>
      <value>1.0000000</value>
      <autosimplify>1</autosimplify>
      <feedbackstyle>2</feedbackstyle>
      <feedbackvariables>
        <text></text>
      </feedbackvariables>
      <node>
        <name>0</name>
        <description></description>
        <answertest>NumAbsolute</answertest>
        <sans>ansPN</sans>
        <tans>taPN</tans>
        <testoptions>3.001</testoptions>
        <quiet>1</quiet>
        <truescoremode>=</truescoremode>
        <truescore>1</truescore>
        <truepenalty></truepenalty>
        <truenextnode>-1</truenextnode>
        <trueanswernote>prtPN-1-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtPN-1-F</falseanswernote>
        <falsefeedback format="html">
          <text></text>
        </falsefeedback>
      </node>
    </prt>
    <prt>
      <name>prtSOK</name>
      <value>1.0000000</value>
      <autosimplify>1</autosimplify>
      <feedbackstyle>1</feedbackstyle>
      <feedbackvariables>
        <text><![CDATA[axisLabelsIncomplete: member(0, ansAxisLabels);
axisLabelsValid: not(axisLabelsIncomplete);

strictTol: 0.18;
relativeTol: 0.03; /* 5 Prozent Abweichung erlauben */
studentSOKType: ansSOK[1];
studentSOKCenter: ansSOK[2];
studentSOKRadius: ansSOK[3];

teacherSOKCenter: interpreteCoords(taSOKCenter, ansAxisLabels);
teacherSOKRadius: taSOKRadius;

sokWasChosen: not(studentSOKType="-1");
sokValidType: is(studentSOKType="flexcircle");

sokCorrectCenter: is(ATNumAbsolute(studentSOKCenter, teacherSOKCenter, strictTol)[2]);
sokCorrectRadius: is(ATNumRelative(studentSOKRadius, teacherSOKRadius, relativeTol)[2]);]]></text>
      </feedbackvariables>
      <node>
        <name>0</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>axisLabelsValid</sans>
        <tans>true</tans>
        <testoptions></testoptions>
        <quiet>1</quiet>
        <truescoremode>+</truescoremode>
        <truescore>0</truescore>
        <truepenalty></truepenalty>
        <truenextnode>1</truenextnode>
        <trueanswernote>prtSOK-1-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtSOK-1-F</falseanswernote>
        <falsefeedback format="html">
          <text><![CDATA[<p>Bitte beschriften Sie beide Koordinatenachsen.</p>]]></text>
        </falsefeedback>
      </node>
      <node>
        <name>1</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>sokWasChosen</sans>
        <tans>true</tans>
        <testoptions></testoptions>
        <quiet>1</quiet>
        <truescoremode>+</truescoremode>
        <truescore>0</truescore>
        <truepenalty></truepenalty>
        <truenextnode>2</truenextnode>
        <trueanswernote>prtSOK-2-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>-</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtSOK-2-F</falseanswernote>
        <falsefeedback format="html">
          <text><![CDATA[<p>Sie haben noch kein Objekt als Stromortskurve markiert.</p>]]></text>
        </falsefeedback>
      </node>
      <node>
        <name>2</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>sokValidType</sans>
        <tans>true</tans>
        <testoptions></testoptions>
        <quiet>1</quiet>
        <truescoremode>+</truescoremode>
        <truescore>0.2</truescore>
        <truepenalty></truepenalty>
        <truenextnode>3</truenextnode>
        <trueanswernote>prtSOK-3-T</trueanswernote>
        <truefeedback format="html">
          <text><![CDATA[<p>Sie haben korrekt bestimmt, dass die Stromortskurve in diesem Fall ein Kreis ist.</p>]]></text>
        </truefeedback>
        <falsescoremode>-</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtSOK-3-F</falseanswernote>
        <falsefeedback format="html">
          <text><![CDATA[<p>Die Stromortskurve sollte in diesem Fall {@if is(studentSOKType="flexvector") then "kein Vektor" else "keine Gerade"@} sein, sondern ein anderes geometrisches Objekt.</p>]]></text>
        </falsefeedback>
      </node>
      <node>
        <name>3</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>sokCorrectCenter</sans>
        <tans>true</tans>
        <testoptions></testoptions>
        <quiet>1</quiet>
        <truescoremode>+</truescoremode>
        <truescore>0.4</truescore>
        <truepenalty></truepenalty>
        <truenextnode>4</truenextnode>
        <trueanswernote>prtSOK-4-T</trueanswernote>
        <truefeedback format="html">
          <text><![CDATA[<p>Der Mittelpunkt Ihrer Stromortskurve ist an der richtigen Stelle.</p>]]></text>
        </truefeedback>
        <falsescoremode>-</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>5</falsenextnode>
        <falseanswernote>prtSOK-4-F</falseanswernote>
        <falsefeedback format="html">
          <text><![CDATA[<p>Der Mittelpunkt Ihrer Stromortskurve ist an der falschen Stelle.</p>]]></text>
        </falsefeedback>
      </node>
      <node>
        <name>4</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>sokCorrectRadius</sans>
        <tans>true</tans>
        <testoptions></testoptions>
        <quiet>1</quiet>
        <truescoremode>+</truescoremode>
        <truescore>0.4</truescore>
        <truepenalty></truepenalty>
        <truenextnode>-1</truenextnode>
        <trueanswernote>prtSOK-5-T</trueanswernote>
        <truefeedback format="html">
          <text><![CDATA[<p>Der Radius Ihrer Stromortskurve ist ebenfalls korrekt.</p>]]></text>
        </truefeedback>
        <falsescoremode>-</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtSOK-5-F</falseanswernote>
        <falsefeedback format="html">
          <text><![CDATA[<p>Der Radius Ihrer Stromortskurve ist nicht korrekt.</p>]]></text>
        </falsefeedback>
      </node>
      <node>
        <name>5</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>sokCorrectRadius</sans>
        <tans>true</tans>
        <testoptions></testoptions>
        <quiet>1</quiet>
        <truescoremode>+</truescoremode>
        <truescore>0.4</truescore>
        <truepenalty></truepenalty>
        <truenextnode>-1</truenextnode>
        <trueanswernote>prtSOK-6-T</trueanswernote>
        <truefeedback format="html">
          <text><![CDATA[<p>Der Radius Ihrer Stromortskurve ist korrekt.</p>]]></text>
        </truefeedback>
        <falsescoremode>-</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtSOK-6-F</falseanswernote>
        <falsefeedback format="html">
          <text><![CDATA[<p>Der Radius Ihrer Stromortskurve ist nicht korrekt.</p>]]></text>
        </falsefeedback>
      </node>
    </prt>
    <prt>
      <name>prtThetaLN</name>
      <value>1.0000000</value>
      <autosimplify>1</autosimplify>
      <feedbackstyle>2</feedbackstyle>
      <feedbackvariables>
        <text></text>
      </feedbackvariables>
      <node>
        <name>0</name>
        <description></description>
        <answertest>NumAbsolute</answertest>
        <sans>ansThetaLN</sans>
        <tans>taThetaLN</tans>
        <testoptions>aTol</testoptions>
        <quiet>1</quiet>
        <truescoremode>=</truescoremode>
        <truescore>1</truescore>
        <truepenalty></truepenalty>
        <truenextnode>-1</truenextnode>
        <trueanswernote>prtThetaLN-1-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtThetaLN-1-F</falseanswernote>
        <falsefeedback format="html">
          <text></text>
        </falsefeedback>
      </node>
    </prt>
    <prt>
      <name>prtUPN</name>
      <value>1.0000000</value>
      <autosimplify>1</autosimplify>
      <feedbackstyle>2</feedbackstyle>
      <feedbackvariables>
        <text></text>
      </feedbackvariables>
      <node>
        <name>0</name>
        <description></description>
        <answertest>NumAbsolute</answertest>
        <sans>ansUPN</sans>
        <tans>taUPN</tans>
        <testoptions>aTol</testoptions>
        <quiet>1</quiet>
        <truescoremode>=</truescoremode>
        <truescore>1</truescore>
        <truepenalty></truepenalty>
        <truenextnode>-1</truenextnode>
        <trueanswernote>prtUPN-1-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtUPN-1-F</falseanswernote>
        <falsefeedback format="html">
          <text></text>
        </falsefeedback>
      </node>
    </prt>
    <prt>
      <name>prtXd</name>
      <value>1.0000000</value>
      <autosimplify>1</autosimplify>
      <feedbackstyle>2</feedbackstyle>
      <feedbackvariables>
        <text></text>
      </feedbackvariables>
      <node>
        <name>0</name>
        <description></description>
        <answertest>NumAbsolute</answertest>
        <sans>ansXd</sans>
        <tans>taXd</tans>
        <testoptions>0.1001</testoptions>
        <quiet>1</quiet>
        <truescoremode>=</truescoremode>
        <truescore>1</truescore>
        <truepenalty></truepenalty>
        <truenextnode>-1</truenextnode>
        <trueanswernote>prtXd-1-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtXd-1-F</falseanswernote>
        <falsefeedback format="html">
          <text></text>
        </falsefeedback>
      </node>
    </prt>
    <prt>
      <name>prtXh</name>
      <value>1.0000000</value>
      <autosimplify>1</autosimplify>
      <feedbackstyle>2</feedbackstyle>
      <feedbackvariables>
        <text></text>
      </feedbackvariables>
      <node>
        <name>0</name>
        <description></description>
        <answertest>NumAbsolute</answertest>
        <sans>ansXh</sans>
        <tans>taXh</tans>
        <testoptions>0.1001</testoptions>
        <quiet>1</quiet>
        <truescoremode>=</truescoremode>
        <truescore>1</truescore>
        <truepenalty></truepenalty>
        <truenextnode>-1</truenextnode>
        <trueanswernote>prtXh-1-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtXh-1-F</falseanswernote>
        <falsefeedback format="html">
          <text></text>
        </falsefeedback>
      </node>
    </prt>
    <prt>
      <name>prtXsigma</name>
      <value>1.0000000</value>
      <autosimplify>1</autosimplify>
      <feedbackstyle>2</feedbackstyle>
      <feedbackvariables>
        <text></text>
      </feedbackvariables>
      <node>
        <name>0</name>
        <description></description>
        <answertest>NumAbsolute</answertest>
        <sans>ansXsigma</sans>
        <tans>taXsigma</tans>
        <testoptions>0.1001</testoptions>
        <quiet>1</quiet>
        <truescoremode>=</truescoremode>
        <truescore>1</truescore>
        <truepenalty></truepenalty>
        <truenextnode>-1</truenextnode>
        <trueanswernote>prtXsigma-1-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtXsigma-1-F</falseanswernote>
        <falsefeedback format="html">
          <text></text>
        </falsefeedback>
      </node>
    </prt>
    <prt>
      <name>prtZD</name>
      <value>1.0000000</value>
      <autosimplify>1</autosimplify>
      <feedbackstyle>1</feedbackstyle>
      <feedbackvariables>
        <text><![CDATA[axisLabelsIncomplete: member(0, ansZDAxisLabels);
axisLabelsValid: not(axisLabelsIncomplete);

pair_elements(lst) := block(
    [result: []],
    for i:1 step 2 thru length(lst) do
        result: endcons([lst[i], lst[i+1]], result),
    return(result)
);

studentList: pair_elements(maplist(lambda([x], float(x)), ansZD));
teacherList: pair_elements(maplist(lambda([x], interpreteCoords(float(x), ansZDAxisLabels)), taZD));


stList: zip_with("[", studentList, teacherList);
zeroTol: 0.1;
angleTol: 0.06; /*ca. 3 Grad*/

fThree(x):=[if is(ATNumAbsolute(x[1][1], x[2][1], 0.25)[2]=true) then "&check;" else "<b>&times;</b>", if is(ATNumAbsolute(mat_norm(matrix(x[1][2]-x[1][1]), frobenius), mat_norm(matrix(x[2][2]-x[2][1]), frobenius), 0.25)[2]=true) then "&check;" else "<b>&times;</b>", if is(ATNumAbsolute(carg((x[1][2]-x[1][1])[1]+%i*(x[1][2]-x[1][1])[2]), carg((x[2][2]-x[2][1])[1]+%i*(x[2][2]-x[2][1])[2]), angleTol)[2]=true) then "&check;" else "<b>&times;</b>"];

fstList: maplist(fThree, stList);
vfstList: map(cons, vecLabels, fstList);

allCorr: every(lambda([x], is(x=["&check;","&check;","&check;"])), fstList);
allFalse: every(lambda([x], is(x=["<b>&times;</b>","<b>&times;</b>","<b>&times;</b>"])), fstList);]]></text>
      </feedbackvariables>
      <node>
        <name>0</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>axisLabelsValid</sans>
        <tans>true</tans>
        <testoptions></testoptions>
        <quiet>1</quiet>
        <truescoremode>+</truescoremode>
        <truescore>0</truescore>
        <truepenalty></truepenalty>
        <truenextnode>1</truenextnode>
        <trueanswernote>prtZD-1-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>=</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtZD-1-F</falseanswernote>
        <falsefeedback format="html">
          <text><![CDATA[<p>Bitte beschriften Sie zuerst beide Koordinatenachsen.</p>]]></text>
        </falsefeedback>
      </node>
      <node>
        <name>1</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>allCorr</sans>
        <tans>true</tans>
        <testoptions></testoptions>
        <quiet>1</quiet>
        <truescoremode>+</truescoremode>
        <truescore>1</truescore>
        <truepenalty></truepenalty>
        <truenextnode>2</truenextnode>
        <trueanswernote>prtZD-2-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>-</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>2</falsenextnode>
        <falseanswernote>prtZD-2-F</falseanswernote>
        <falsefeedback format="html">
          <text></text>
        </falsefeedback>
      </node>
      <node>
        <name>2</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>allFalse</sans>
        <tans>true</tans>
        <testoptions></testoptions>
        <quiet>1</quiet>
        <truescoremode>+</truescoremode>
        <truescore>0</truescore>
        <truepenalty></truepenalty>
        <truenextnode>3</truenextnode>
        <trueanswernote>prtZD-3-T</trueanswernote>
        <truefeedback format="html">
          <text></text>
        </truefeedback>
        <falsescoremode>+</falsescoremode>
        <falsescore>0.5</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>3</falsenextnode>
        <falseanswernote>prtZD-3-F</falseanswernote>
        <falsefeedback format="html">
          <text></text>
        </falsefeedback>
      </node>
      <node>
        <name>3</name>
        <description></description>
        <answertest>AlgEquiv</answertest>
        <sans>true</sans>
        <tans>true</tans>
        <testoptions></testoptions>
        <quiet>1</quiet>
        <truescoremode>+</truescoremode>
        <truescore>0</truescore>
        <truepenalty></truepenalty>
        <truenextnode>-1</truenextnode>
        <trueanswernote>prtZD-4-T</trueanswernote>
        <truefeedback format="html">
          <text><![CDATA[<style>
table#vfst {
            /*width: 50%;*/
            margin: 20px auto;
            border-collapse: collapse;
        }
table#vfst th, td {
            padding: 10px;
            border: 1px solid #ddd;
            text-align: center;
        }
table#vfst th {
            background-color: #f4f4f4;
        }
table#vfst tr:nth-child(odd) {
            background-color: #f9f9f9;
        }
table#vfst tr:nth-child(even) {
            background-color: #fff;
        }
</style>
<table id="vfst">
    <tr><th>Vektor</th><th>Startpunkt</th><th>Länge</th><th>Neigung</th></tr>
[[foreach row="args(vfstList)"]]
    <tr>[[foreach cell="row"]]<td>{@cell@}</td>[[/foreach]]</tr>
[[/foreach]]
</table>]]></text>
        </truefeedback>
        <falsescoremode>-</falsescoremode>
        <falsescore>0</falsescore>
        <falsepenalty></falsepenalty>
        <falsenextnode>-1</falsenextnode>
        <falseanswernote>prtZD-4-F</falseanswernote>
        <falsefeedback format="html">
          <text></text>
        </falsefeedback>
      </node>
    </prt>
    <qtest>
      <testcase>1</testcase>
      <description>Testfall, der annimmt, dass die Eingabe der Trainer/innen die volle Punktezahl erreicht.</description>
      <testinput>
        <name>ansAxisLabels</name>
        <value>[1,4]</value>
      </testinput>
      <testinput>
        <name>ansBP</name>
        <value>taBP</value>
      </testinput>
      <testinput>
        <name>ansBzReason</name>
        <value>taBzReason</value>
      </testinput>
      <testinput>
        <name>ansBzYesNo</name>
        <value>first(mcq_correct(taddBzYesNo))</value>
      </testinput>
      <testinput>
        <name>ansIENFiktiv</name>
        <value>taIENFiktiv</value>
      </testinput>
      <testinput>
        <name>ansIN</name>
        <value>taIN</value>
      </testinput>
      <testinput>
        <name>ansIstrichE</name>
        <value>taIstrichE</value>
      </testinput>
      <testinput>
        <name>ansPN</name>
        <value>taPN</value>
      </testinput>
      <testinput>
        <name>ansSOK</name>
        <value>taSOK</value>
      </testinput>
      <testinput>
        <name>ansStateStorage</name>
        <value><![CDATA[""]]></value>
      </testinput>
      <testinput>
        <name>ansThetaLN</name>
        <value>taThetaLN</value>
      </testinput>
      <testinput>
        <name>ansUPN</name>
        <value>taUPN</value>
      </testinput>
      <testinput>
        <name>ansXd</name>
        <value>taXd</value>
      </testinput>
      <testinput>
        <name>ansXh</name>
        <value>taXh</value>
      </testinput>
      <testinput>
        <name>ansXsigma</name>
        <value>taXsigma</value>
      </testinput>
      <expected>
        <name>prtBP</name>
        <expectedscore>1.0000000</expectedscore>
        <expectedpenalty>0.0000000</expectedpenalty>
        <expectedanswernote>prtBP-5-F</expectedanswernote>
      </expected>
      <expected>
        <name>prtBzReason</name>
        <expectedscore>1.0000000</expectedscore>
        <expectedpenalty>0.0000000</expectedpenalty>
        <expectedanswernote>prtBzReason-1-T</expectedanswernote>
      </expected>
      <expected>
        <name>prtBzYesNo</name>
        <expectedscore>1.0000000</expectedscore>
        <expectedpenalty>0.0000000</expectedpenalty>
        <expectedanswernote>prtBzYesNo-1-T</expectedanswernote>
      </expected>
      <expected>
        <name>prtIENFiktiv</name>
        <expectedscore>1.0000000</expectedscore>
        <expectedpenalty>0.0000000</expectedpenalty>
        <expectedanswernote>prtIENFiktiv-1-T</expectedanswernote>
      </expected>
      <expected>
        <name>prtIN</name>
        <expectedscore>1.0000000</expectedscore>
        <expectedpenalty>0.0000000</expectedpenalty>
        <expectedanswernote>prtIN-1-T</expectedanswernote>
      </expected>
      <expected>
        <name>prtIstrichE</name>
        <expectedscore>1.0000000</expectedscore>
        <expectedpenalty>0.0000000</expectedpenalty>
        <expectedanswernote>prtIstrichE-1-T</expectedanswernote>
      </expected>
      <expected>
        <name>prtPN</name>
        <expectedscore>1.0000000</expectedscore>
        <expectedpenalty>0.0000000</expectedpenalty>
        <expectedanswernote>prtPN-1-T</expectedanswernote>
      </expected>
      <expected>
        <name>prtSOK</name>
        <expectedscore>1.0000000</expectedscore>
        <expectedpenalty>0.0000000</expectedpenalty>
        <expectedanswernote>prtSOK-6-F</expectedanswernote>
      </expected>
      <expected>
        <name>prtThetaLN</name>
        <expectedscore>1.0000000</expectedscore>
        <expectedpenalty>0.0000000</expectedpenalty>
        <expectedanswernote>prtThetaLN-1-T</expectedanswernote>
      </expected>
      <expected>
        <name>prtUPN</name>
        <expectedscore>1.0000000</expectedscore>
        <expectedpenalty>0.0000000</expectedpenalty>
        <expectedanswernote>prtUPN-1-T</expectedanswernote>
      </expected>
      <expected>
        <name>prtXd</name>
        <expectedscore>1.0000000</expectedscore>
        <expectedpenalty>0.0000000</expectedpenalty>
        <expectedanswernote>prtXd-1-T</expectedanswernote>
      </expected>
      <expected>
        <name>prtXh</name>
        <expectedscore>1.0000000</expectedscore>
        <expectedpenalty>0.0000000</expectedpenalty>
        <expectedanswernote>prtXh-1-T</expectedanswernote>
      </expected>
      <expected>
        <name>prtXsigma</name>
        <expectedscore>1.0000000</expectedscore>
        <expectedpenalty>0.0000000</expectedpenalty>
        <expectedanswernote>prtXsigma-1-T</expectedanswernote>
      </expected>
    </qtest>
  </question>

</quiz>